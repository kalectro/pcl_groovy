diff --git a/.gitignore b/.gitignore
index 88ea6d4..96475df 100644
--- a/.gitignore
+++ b/.gitignore
@@ -37,3 +37,8 @@ doc/html
 Debug
 Release
 *.user
+android/build-*
+android/ndk-modules/libusb-1.0/include
+android/ndk-modules/libusb-1.0/lib
+android/LibusbSupport/gen
+android/LibusbSupport/proguard-project.txt
diff --git a/AUTHORS b/AUTHORS
index b43d995..960d1a7 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -34,6 +34,7 @@ Orin Eman
 Pekka Nikander
 Peter Stuge
 Rob Walker
+Roman Donchenko
 Sean McBride
 Sebastian Pipping
 Stephan Meyer
diff --git a/README.android b/README.android
new file mode 100644
index 0000000..786b1ff
--- /dev/null
+++ b/README.android
@@ -0,0 +1,64 @@
+Overview
+========
+
+This version of libusb has been modified to work on Android. Besides some build
+changes, the buggest addition is that libusb now tries to use Android's Java
+USB host API to open the the devices, which means it will be able to
+successfully open them, even if the application is running as non-root (which
+they usually do).
+
+This modification is not perfect, read the Caveats section before using it.
+
+Building and using
+==================
+
+To build libusb for Android, you use the usual configure/make machinery,
+however, there's a build script in the 'android' directory, which simplifies
+the job. To use it, prepare an Android standalone toolchain (see
+STANDALONE-TOOLCHAIN.html in Android NDK documentation for how to do this).
+
+Then, make sure arm-linux-androideabi-gcc is in your PATH, and do the following:
+
+  cd android
+  ./build.sh armeabi
+  ./build.sh armeabi-v7a
+
+This will build the libraries and place them into
+'android/ndk-modules/libusb-1.0'.
+
+If you're using ndk-build as your build system, you can use libusb by adding
+the 'android/ndk-modules' directory to your NDK_MODULE_PATH environment
+variable, and then appending:
+
+  $(call import-module,libusb-1.0)
+
+to your Android.mk file.
+
+Caveats
+=======
+
+For this version of libusb to work, several other requirements must be
+fulfilled:
+
+1) Include the org.libusb.UsbHelper class from the 'android/LibusbSupport'
+   directory in your application. The directory is also usable as an Android
+   library project.
+
+2) Have an application class (see
+   <http://developer.android.com/reference/android/app/Application.html>).
+   In that class's onCreate(), put the following line:
+
+     UsbHelper.useContext(getApplicationContext());
+
+3) You must load libusb into the JVM before using it (for example, in the
+   application class):
+
+     System.loadLibrary("usb-1.0")
+
+4) Beware: libusb will open a USB device if the application's user has given
+   permission to do so; however, it will not ask for that permission! It is
+   impossible for it to do so, since libusb_open is synchronous, and
+   android.hardware.usb.UsbManager.requestPermission is not. You must request
+   this permission yourself; see
+   <http://developer.android.com/guide/topics/connectivity/usb/host.html#permission-d>
+   for details.
diff --git a/android/LibusbSupport/AndroidManifest.xml b/android/LibusbSupport/AndroidManifest.xml
new file mode 100644
index 0000000..b4f950c
--- /dev/null
+++ b/android/LibusbSupport/AndroidManifest.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+      package="org.libusb">
+    <uses-sdk android:minSdkVersion="12" />
+    <uses-feature android:name="android.hardware.usb.host" android:required="false" />
+</manifest>
diff --git a/android/LibusbSupport/project.properties b/android/LibusbSupport/project.properties
new file mode 100644
index 0000000..b2ed0b0
--- /dev/null
+++ b/android/LibusbSupport/project.properties
@@ -0,0 +1,15 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+
+android.library=true
+# Project target.
+target=android-16
diff --git a/android/LibusbSupport/src/org/libusb/UsbHelper.java b/android/LibusbSupport/src/org/libusb/UsbHelper.java
new file mode 100644
index 0000000..1f78044
--- /dev/null
+++ b/android/LibusbSupport/src/org/libusb/UsbHelper.java
@@ -0,0 +1,26 @@
+package org.libusb;
+
+import android.app.Service;
+import android.content.Context;
+import android.hardware.usb.UsbDevice;
+import android.hardware.usb.UsbDeviceConnection;
+import android.hardware.usb.UsbManager;
+
+public class UsbHelper {
+    private static UsbManager manager;
+
+    public static UsbManager getManager() {
+        return manager;
+    }
+
+    public static void useContext(Context context) {
+        manager = (UsbManager) context.getSystemService(Service.USB_SERVICE);
+    }
+
+    @SuppressWarnings("UnusedDeclaration")
+    public static UsbDeviceConnection openDevice(String path) {
+        UsbDevice device = manager.getDeviceList().get(path);
+        if (device == null) return null;
+        return manager.openDevice(device);
+    }
+}
diff --git a/android/build.sh b/android/build.sh
new file mode 100755
index 0000000..0e1cf7a
--- /dev/null
+++ b/android/build.sh
@@ -0,0 +1,42 @@
+#!/bin/bash
+
+set -e
+dir=$(dirname "$0")
+
+if [ $# -ne 1 ]; then
+  echo "Usage: $0 (armeabi | armeabi-v7a)"
+  exit 1
+fi
+
+build=$(sh $dir/../config.guess)
+
+echo "Guessed the build system as ${build}."
+
+cflags="-O2 -g"
+
+arch=$1
+
+case $arch in
+armeabi)
+  host=arm-linux-androideabi
+  cflags="$cflags -mthumb"
+  ldflags="-Wl,--fix-cortex-a8 -Wl,--no-undefined"
+  ;;
+armeabi-v7a)
+  host=arm-linux-androideabi
+  cflags="$cflags -mthumb -march=armv7-a -mfloat-abi=softfp"
+  ldflags="-Wl,--fix-cortex-a8 -Wl,--no-undefined"
+  ;;
+*)
+  echo "Unsupported architecture: $arch"
+  exit 1
+esac
+
+mkdir -p $dir/build-$arch
+(cd $dir/build-$arch && ../../configure --host=$host --build=$build CFLAGS="$cflags" LDFLAGS="$ldflags" && make)
+
+echo "Copying headers and libraries..."
+mkdir -p $dir/ndk-modules/libusb-1.0/{include/libusb-1.0,lib/$arch}
+cp $dir/../libusb/libusb.h $dir/ndk-modules/libusb-1.0/include/libusb-1.0
+cp $dir/build-$arch/libusb/.libs/libusb-1.0.so $dir/ndk-modules/libusb-1.0/lib/$arch
+
diff --git a/android/ndk-modules/libusb-1.0/Android.mk b/android/ndk-modules/libusb-1.0/Android.mk
new file mode 100644
index 0000000..57cd8f2
--- /dev/null
+++ b/android/ndk-modules/libusb-1.0/Android.mk
@@ -0,0 +1,10 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+LOCAL_MODULE := libusb-1.0
+
+LOCAL_SRC_FILES := lib/$(TARGET_ARCH_ABI)/libusb-1.0.so
+LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include/libusb-1.0
+LOCAL_EXPORT_LDLIBS := -llog
+
+include $(PREBUILT_SHARED_LIBRARY)
diff --git a/configure.ac b/configure.ac
index f9e648e..0bb2aa4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -17,15 +17,6 @@ LU_DEFINE_VERSION_RC_ATOM([LIBUSB_RC])
 
 AC_INIT([libusb], LIBUSB_MAJOR[.]LIBUSB_MINOR[.]LIBUSB_MICRO[]LIBUSB_RC, [libusb-devel@lists.sourceforge.net], [libusb], [http://www.libusb.org/])
 
-# Library versioning
-# These numbers should be tweaked on every release. Read carefully:
-# http://www.gnu.org/software/libtool/manual/html_node/Updating-version-info.html
-# http://sourceware.org/autobook/autobook/autobook_91.html
-lt_current="1"
-lt_revision="0"
-lt_age="1"
-LTLDFLAGS="-version-info ${lt_current}:${lt_revision}:${lt_age}"
-
 AM_INIT_AUTOMAKE
 AM_MAINTAINER_MODE
 
@@ -42,13 +33,13 @@ AC_C_INLINE
 AM_PROG_CC_C_O
 AC_DEFINE([_GNU_SOURCE], 1, [Use GNU extensions])
 
-LTLDFLAGS="${LTLDFLAGS} -no-undefined"
-
 AC_MSG_CHECKING([operating system])
 case $host in
 *-linux*)
 	AC_MSG_RESULT([Linux])
 	backend="linux"
+
+	AC_CHECK_DECL(__ANDROID__, android=true, android=false)
 	;;
 *-darwin*)
 	AC_MSG_RESULT([Darwin/Mac OS X])
@@ -74,14 +65,30 @@ case $host in
 *)
 	AC_MSG_ERROR([unsupported operating system])
 esac
+
+if $android; then
+LTLDFLAGS="-avoid-version"
+else
+# Library versioning
+# These numbers should be tweaked on every release. Read carefully:
+# http://www.gnu.org/software/libtool/manual/html_node/Updating-version-info.html
+# http://sourceware.org/autobook/autobook/autobook_91.html
+lt_current="1"
+lt_revision="0"
+lt_age="1"
+LTLDFLAGS="-version-info ${lt_current}:${lt_revision}:${lt_age}"
+fi
+
+LTLDFLAGS="${LTLDFLAGS} -no-undefined"
+
 case $backend in
 linux)
 	AC_DEFINE(OS_LINUX, 1, [Linux backend])
 	AC_SUBST(OS_LINUX)
 	AC_CHECK_LIB(rt, clock_gettime, PC_LIBS_PRIVATE="-lrt")
+	AC_CHECK_LIB(pthread, pthread_create, [PC_LIBS_PRIVATE="${PC_LIBS_PRIVATE} -pthread"; THREAD_CFLAGS="-pthread"], THREAD_CFLAGS="")
 	threads="posix"
-	THREAD_CFLAGS="-pthread"
-	PC_LIBS_PRIVATE="${PC_LIBS_PRIVATE} -pthread"
+
 	AC_CHECK_HEADERS([poll.h])
 	AC_DEFINE([POLL_NFDS_TYPE],[nfds_t],[type of second poll() argument])
 	;;
@@ -126,6 +133,7 @@ AM_CONDITIONAL(THREADS_POSIX, test "x$threads" = xposix)
 if test "$threads" = posix; then
 	AC_DEFINE(THREADS_POSIX, 1, [Use POSIX Threads])
 fi
+AM_CONDITIONAL(ANDROID, $android)
 
 # timerfd
 AC_CHECK_HEADER([sys/timerfd.h], [timerfd_h=1], [timerfd_h=0])
@@ -157,6 +165,10 @@ fi
 
 AC_CHECK_TYPES(struct timespec)
 
+if $android; then
+	AC_SEARCH_LIBS([__android_log_vprint], [log])
+fi
+
 # Message logging
 AC_ARG_ENABLE([log], [AS_HELP_STRING([--disable-log], [disable all logging])],
 	[log_enabled=$enableval],
diff --git a/libusb/Makefile.am b/libusb/Makefile.am
index 3316ebc..9363e2d 100644
--- a/libusb/Makefile.am
+++ b/libusb/Makefile.am
@@ -37,12 +37,18 @@ else
 THREADS_SRC = os/threads_windows.h os/threads_windows.c
 endif
 
+if ANDROID
+ANDROID_JAVA_SRC = os/android_java.c
+else
+ANDROID_JAVA_SRC =
+endif
+
 libusb_1_0_la_CFLAGS = $(VISIBILITY_CFLAGS) $(AM_CFLAGS) $(THREAD_CFLAGS) \
 	-DLIBUSB_DESCRIBE=\"`git --git-dir "$(top_srcdir)/.git" describe --tags 2>/dev/null`\"
 libusb_1_0_la_LDFLAGS = $(LTLDFLAGS)
 libusb_1_0_la_SOURCES = libusbi.h core.c descriptor.c io.c sync.c $(OS_SRC) \
 	os/linux_usbfs.h os/darwin_usb.h os/windows_usb.h \
-	$(THREADS_SRC) \
+	$(THREADS_SRC) $(ANDROID_JAVA_SRC) \
 	os/poll_posix.h os/poll_windows.h
 
 hdrdir = $(includedir)/libusb-1.0
diff --git a/libusb/core.c b/libusb/core.c
index 767dcbf..64e4a40 100644
--- a/libusb/core.c
+++ b/libusb/core.c
@@ -31,6 +31,10 @@
 #include <sys/time.h>
 #endif
 
+#ifdef __ANDROID__
+#include <android/log.h>
+#endif
+
 #include "libusbi.h"
 
 #if defined(OS_LINUX)
@@ -1768,6 +1772,34 @@ void usbi_log_v(struct libusb_context *ctx, enum usbi_log_level level,
 		return;
 #endif
 
+#ifdef __ANDROID__
+	android_LogPriority android_level;
+
+	switch (level) {
+	case LOG_LEVEL_INFO:
+		android_level = ANDROID_LOG_INFO;
+		break;
+	case LOG_LEVEL_WARNING:
+		android_level = ANDROID_LOG_WARN;
+		break;
+	case LOG_LEVEL_ERROR:
+		android_level = ANDROID_LOG_ERROR;
+		break;
+	case LOG_LEVEL_DEBUG:
+		android_level = ANDROID_LOG_DEBUG;
+		break;
+	default:
+		android_level = ANDROID_LOG_UNKNOWN;
+		break;
+	}
+
+	char android_tag[256]; /* ought to be enough */
+
+	snprintf(android_tag, sizeof android_tag, "libusb(%s)", function);
+
+	__android_log_vprint(android_level, android_tag, format, args);
+#endif
+
 	usbi_gettimeofday(&now, NULL);
 	if (!first.tv_sec) {
 		first.tv_sec = now.tv_sec;
diff --git a/libusb/io.c b/libusb/io.c
index e9bd312..9529b67 100644
--- a/libusb/io.c
+++ b/libusb/io.c
@@ -34,6 +34,13 @@
 #include <sys/timerfd.h>
 #endif
 
+#if !defined(TIMESPEC_TO_TIMEVAL)
+#define TIMESPEC_TO_TIMEVAL(tv, ts) {                   \
+	(tv)->tv_sec = (long)(ts)->tv_sec;                  \
+	(tv)->tv_usec = (long)(ts)->tv_nsec / 1000;         \
+}
+#endif
+
 #include "libusbi.h"
 
 /**
diff --git a/libusb/os/android_java.c b/libusb/os/android_java.c
new file mode 100644
index 0000000..78becd0
--- /dev/null
+++ b/libusb/os/android_java.c
@@ -0,0 +1,215 @@
+/*
+* Android interop for libusb
+* Copyright (c) 2012 Roman Donchenko <roman.donchenko@itseez.com>
+*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#include <stdbool.h>
+#include <jni.h>
+
+#include "android_java.h"
+#include "libusbi.h"
+
+static JavaVM *java_vm = NULL;
+
+static jclass java_lang_Throwable = NULL;
+static jmethodID java_lang_Throwable_toString;
+
+static jclass android_hardware_usb_UsbDeviceConnection = NULL;
+static jmethodID android_hardware_usb_UsbDeviceConnection_getFileDescriptor;
+static jmethodID android_hardware_usb_UsbDeviceConnection_close;
+
+static jclass org_libusb_UsbHelper = NULL;
+static jmethodID org_libusb_UsbHelper_openDevice;
+
+static void log_exception(JNIEnv * env, jthrowable exception, struct libusb_context *ctx, const char * function)
+{
+	jstring exc_string = (*env)->CallObjectMethod(env, exception, java_lang_Throwable_toString);
+
+	if ((*env)->ExceptionCheck(env)) {
+		(*env)->ExceptionClear(env);
+		usbi_log(ctx, LOG_LEVEL_ERROR, function, "a Java exception occurred, but toString() failed");
+	} else if (!exc_string) {
+		usbi_log(ctx, LOG_LEVEL_ERROR, function, "a Java exception occurred, but toString() is null");				
+	} else {
+		const char * exc_string_chars = (*env)->GetStringUTFChars(env, exc_string, NULL);
+		usbi_log(ctx, LOG_LEVEL_ERROR, function, "a Java exception occurred: %s", exc_string_chars);				
+		(*env)->ReleaseStringUTFChars(env, exc_string, exc_string_chars);
+	}
+}
+
+JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void * reserved)
+{
+	java_vm = vm;
+	usbi_dbg("loaded into JVM");
+
+	JNIEnv * env;
+	void * void_env;
+	(*java_vm)->GetEnv(java_vm, &void_env, JNI_VERSION_1_6);
+
+	env = void_env;
+
+	jclass clazz;
+
+	clazz = (*env)->FindClass(env, "java/lang/Throwable");
+	if (!clazz) (*env)->FatalError(env, "Couldn't find java.lang.Throwable!");
+	java_lang_Throwable = (*env)->NewGlobalRef(env, clazz);
+
+	java_lang_Throwable_toString = (*env)->GetMethodID(env, java_lang_Throwable,
+		"toString", "()Ljava/lang/String;");
+	if (!java_lang_Throwable_toString) (*env)->FatalError(env, "Couldn't find java.lang.Throwable.toString()!");
+
+	clazz = (*env)->FindClass(env, "android/hardware/usb/UsbDeviceConnection");
+	if (!clazz) goto cleanup;
+	android_hardware_usb_UsbDeviceConnection = (*env)->NewGlobalRef(env, clazz);
+
+	android_hardware_usb_UsbDeviceConnection_getFileDescriptor = (*env)->GetMethodID(env, android_hardware_usb_UsbDeviceConnection,
+		"getFileDescriptor", "()I");
+	if (!android_hardware_usb_UsbDeviceConnection_getFileDescriptor) goto cleanup;
+
+	android_hardware_usb_UsbDeviceConnection_close = (*env)->GetMethodID(env, android_hardware_usb_UsbDeviceConnection,
+		"close", "()V");
+	if (!android_hardware_usb_UsbDeviceConnection_close) goto cleanup;
+
+	clazz = (*env)->FindClass(env, "org/libusb/UsbHelper");
+	if (!clazz) goto cleanup;
+	org_libusb_UsbHelper = (*env)->NewGlobalRef(env, clazz);
+
+	org_libusb_UsbHelper_openDevice = (*env)->GetStaticMethodID(env, org_libusb_UsbHelper,
+		"openDevice", "(Ljava/lang/String;)Landroid/hardware/usb/UsbDeviceConnection;");
+	if (!org_libusb_UsbHelper_openDevice) goto cleanup;
+
+	usbi_dbg("found all Java classes and IDs");
+
+cleanup:;
+
+	jthrowable exception;
+	if ((exception = (*env)->ExceptionOccurred(env))) {
+		(*env)->ExceptionClear(env);
+		log_exception(env, exception, NULL, __func__);
+		java_vm = NULL;
+	}
+
+	return JNI_VERSION_1_6;
+}
+
+JNIEXPORT void JNI_OnUnload(JavaVM* vm, void* reserved)
+{
+	JNIEnv * env;
+	void * void_env;
+	(*java_vm)->GetEnv(java_vm, &void_env, JNI_VERSION_1_6);
+
+	env = void_env;
+
+	if (java_lang_Throwable)
+		(*env)->DeleteGlobalRef(env, java_lang_Throwable);
+	if (android_hardware_usb_UsbDeviceConnection)
+		(*env)->DeleteGlobalRef(env, android_hardware_usb_UsbDeviceConnection);
+	if (org_libusb_UsbHelper)
+		(*env)->DeleteGlobalRef(env, org_libusb_UsbHelper);
+
+	usbi_dbg("unloaded from JVM");
+}
+
+void android_java_open(struct libusb_context * ctx, const char * path, int * fd, jobject * connection)
+{
+	*fd = -1;
+	*connection = NULL;
+	bool success = false;
+
+	if (!java_vm) return;
+
+	JNIEnv * env;
+	void * void_env;
+	bool had_to_attach = false;
+	jint status = (*java_vm)->GetEnv(java_vm, &void_env, JNI_VERSION_1_6);
+
+	if (status == JNI_EDETACHED) {
+		(*java_vm)->AttachCurrentThread(java_vm, &env, NULL);
+		had_to_attach = true;
+	} else {
+		env = void_env;
+	}
+
+	jstring path_string = (*env)->NewStringUTF(env, path);
+
+	jobject connection_local = (*env)->CallStaticObjectMethod(env, org_libusb_UsbHelper, org_libusb_UsbHelper_openDevice, path_string);
+	if ((*env)->ExceptionCheck(env)) goto cleanup;
+
+	if (!connection_local) {
+		usbi_err(ctx, "couldn't open device via Java API");
+		goto cleanup;
+	}
+
+	*connection = (*env)->NewGlobalRef(env, connection_local);
+
+	*fd = (*env)->CallIntMethod(env, *connection, android_hardware_usb_UsbDeviceConnection_getFileDescriptor);
+	if ((*env)->ExceptionCheck(env)) goto cleanup;
+
+	success = true;
+
+cleanup:
+
+	if (!success) {
+		jthrowable exception;
+		if ((exception = (*env)->ExceptionOccurred(env))) {
+			(*env)->ExceptionClear(env);
+			log_exception(env, exception, ctx, __func__);
+		}
+
+		*fd = -1;
+		if (*connection) {
+			(*env)->DeleteGlobalRef(env, connection);
+			*connection = NULL;
+		}
+	}
+
+	if (had_to_attach) {
+		(*java_vm)->DetachCurrentThread(java_vm);
+	}
+}
+
+void android_java_close(struct libusb_context * ctx, jobject connection)
+{
+	if (!java_vm) return;
+
+	JNIEnv * env;
+	void * void_env;
+	bool had_to_attach = false;
+	jint status = (*java_vm)->GetEnv(java_vm, &void_env, JNI_VERSION_1_6);
+
+	if (status == JNI_EDETACHED) {
+		(*java_vm)->AttachCurrentThread(java_vm, &env, NULL);
+		had_to_attach = true;
+	} else {
+		env = void_env;
+	}
+
+	(*env)->CallVoidMethod(env, connection, android_hardware_usb_UsbDeviceConnection_close);
+
+	jthrowable exception;
+	if ((exception = (*env)->ExceptionOccurred(env))) {
+		(*env)->ExceptionClear(env);
+		log_exception(env, exception, NULL, __func__);
+	}
+
+	(*env)->DeleteGlobalRef(env, connection);
+
+	if (had_to_attach) {
+		(*java_vm)->DetachCurrentThread(java_vm);
+	}
+}
+
diff --git a/libusb/os/android_java.h b/libusb/os/android_java.h
new file mode 100644
index 0000000..bd458bb
--- /dev/null
+++ b/libusb/os/android_java.h
@@ -0,0 +1,31 @@
+/*
+* Android interop for libusb (declarations)
+* Copyright (c) 2012 Roman Donchenko <roman.donchenko@itseez.com>
+*
+* This library is free software; you can redistribute it and/or
+* modify it under the terms of the GNU Lesser General Public
+* License as published by the Free Software Foundation; either
+* version 2.1 of the License, or (at your option) any later version.
+*
+* This library is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+* Lesser General Public License for more details.
+*
+* You should have received a copy of the GNU Lesser General Public
+* License along with this library; if not, write to the Free Software
+* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+#ifndef ANDROID_JAVA_H
+#define ANDROID_JAVA_H
+
+#include <jni.h>
+
+#include "libusbi.h"
+
+void android_java_open(struct libusb_context * ctx, const char * path, int * fd, jobject * connection);
+void android_java_close(struct libusb_context * ctx, jobject connection);
+
+#endif
+
diff --git a/libusb/os/linux_usbfs.c b/libusb/os/linux_usbfs.c
index 02d182d..44527ea 100644
--- a/libusb/os/linux_usbfs.c
+++ b/libusb/os/linux_usbfs.c
@@ -37,6 +37,11 @@
 #include "libusbi.h"
 #include "linux_usbfs.h"
 
+#ifdef __ANDROID__
+#include <jni.h>
+#include "android_java.h"
+#endif
+
 /* sysfs vs usbfs:
  * opening a usbfs node causes the device to be resumed, so we attempt to
  * avoid this during enumeration.
@@ -116,6 +121,9 @@ struct linux_device_priv {
 
 struct linux_device_handle_priv {
 	int fd;
+#ifdef __ANDROID__
+	jobject connection;
+#endif
 };
 
 enum reap_action {
@@ -1218,7 +1226,13 @@ static int op_open(struct libusb_device_handle *handle)
 
 	_get_usbfs_path(handle->dev, filename);
 	usbi_dbg("opening %s", filename);
+
+#ifdef __ANDROID__
+	android_java_open(HANDLE_CTX(handle), filename, &hpriv->fd, &hpriv->connection);
+	if (hpriv->fd < 0) hpriv->fd = open(filename, O_RDWR);
+#else
 	hpriv->fd = open(filename, O_RDWR);
+#endif
 	if (hpriv->fd < 0) {
 		if (errno == EACCES) {
 			usbi_err(HANDLE_CTX(handle), "libusb couldn't open USB device %s: "
@@ -1242,9 +1256,16 @@ static int op_open(struct libusb_device_handle *handle)
 
 static void op_close(struct libusb_device_handle *dev_handle)
 {
-	int fd = _device_handle_priv(dev_handle)->fd;
-	usbi_remove_pollfd(HANDLE_CTX(dev_handle), fd);
-	close(fd);
+	struct linux_device_handle_priv *hpriv = _device_handle_priv(dev_handle);
+
+	usbi_remove_pollfd(HANDLE_CTX(dev_handle), hpriv->fd);
+
+#ifdef __ANDROID__
+	if (hpriv->connection) android_java_close(HANDLE_CTX(dev_handle), hpriv->connection);
+	else close(hpriv->fd);
+#else
+	close(hpriv->fd);
+#endif
 }
 
 static int op_get_configuration(struct libusb_device_handle *handle,
