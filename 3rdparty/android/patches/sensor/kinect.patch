Add Kinect support.

From: Roman Donchenko <roman.donchenko@itseez.com>

This patch is originally from <https://kforge.ros.org/openni/drivers/>,
modified by me.
---
 Source/XnDeviceSensorV2/Bayer.cpp                  | 1233 +++++++++++++++++++-
 Source/XnDeviceSensorV2/Registration.cpp           |   41 -
 Source/XnDeviceSensorV2/XnDataProcessor.h          |    3 
 Source/XnDeviceSensorV2/XnDeviceSensorIO.cpp       |   46 -
 Source/XnDeviceSensorV2/XnDeviceSensorIO.h         |   11 
 Source/XnDeviceSensorV2/XnDeviceSensorProtocol.h   |    4 
 Source/XnDeviceSensorV2/XnFirmwareStreams.cpp      |   17 
 Source/XnDeviceSensorV2/XnHostProtocol.h           |    4 
 Source/XnDeviceSensorV2/XnSensorDepthStream.cpp    |    2 
 Source/XnDeviceSensorV2/XnSensorDepthStream.h      |    4 
 Source/XnDeviceSensorV2/XnSensorFirmwareParams.cpp |    8 
 Source/XnDeviceSensorV2/XnSensorIRStream.cpp       |    2 
 Source/XnDeviceSensorV2/XnSensorImageStream.cpp    |   79 +
 Source/XnDeviceSensorV2/XnSensorImageStream.h      |    4 
 14 files changed, 1324 insertions(+), 134 deletions(-)

diff --git a/Source/XnDeviceSensorV2/Bayer.cpp b/Source/XnDeviceSensorV2/Bayer.cpp
index ab27c86..cead14f 100644
--- a/Source/XnDeviceSensorV2/Bayer.cpp
+++ b/Source/XnDeviceSensorV2/Bayer.cpp
@@ -20,104 +20,1207 @@
 *                                                                           *
 ****************************************************************************/
 //---------------------------------------------------------------------------
+/****************************************************************************
+ * Edited 12.04.2011 by Raphael Dumusc                                      *
+ * Incorporated ROS code for improved Bayer Pattern to RGB conversion.      *
+ ***************************************************************************/
 // Includes
+ /*
+ The ROS bayer pattern to RGB conversion
+ Modified to be used in Avin's mod of the Primesense driver.
+ Original code available here:
+ http://www.ros.org/doc/api/openni_camera/html/openni__image__bayer__grbg_8cpp_source.html
+*/
+
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011 2011 Willow Garage, Inc.
+ *    Suat Gedikli <gedikli@willowgarage.com>
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 //---------------------------------------------------------------------------
 #include "Bayer.h"
-#include <math.h>
+#include <sstream>
+#include <iostream>
 
+#define AVG(a,b) (((int)(a) + (int)(b)) >> 1)
+#define AVG3(a,b,c) (((int)(a) + (int)(b) + (int)(c)) / 3)
+#define AVG4(a,b,c,d) (((int)(a) + (int)(b) + (int)(c) + (int)(d)) >> 2)
+#define WAVG4(a,b,c,d,x,y)  ( ( ((int)(a) + (int)(b)) * (int)(x) + ((int)(c) + (int)(d)) * (int)(y) ) / ( 2 * ((int)(x) + (int(y))) ) )
+using namespace std;
 //---------------------------------------------------------------------------
+typedef enum
+{
+	Bilinear = 0,
+	EdgeAware,
+	EdgeAwareWeighted
+} DebayeringMethod;
 // Global Variables
+void BayerUpdateGamma(float fGammaCorr)
+{
+}
 //---------------------------------------------------------------------------
-XnUInt8 Gamma[256] = {
-	0,      1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
-	16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
-	32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,
-	48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,
-	64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79,
-	80,    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,
-	96,    97,    98,    99,    100,   101,   102,   103,   104,   105,   106,   107,   108,   109,   110,   111,
-	112,   113,   114,   115,   116,   117,   118,   119,   120,   121,   122,   123,   124,   125,   126,   127,
-	128,   129,   130,   131,   132,   133,   134,   135,   136,   137,   138,   139,   140,   141,   142,   143,
-	144,   145,   146,   147,   148,   149,   150,   151,   152,   153,   154,   155,   156,   157,   158,   159,
-	160,   161,   162,   163,   164,   165,   166,   167,   168,   169,   170,   171,   172,   173,   174,   175,
-	176,   177,   178,   179,   180,   181,   182,   183,   184,   185,   186,   187,   188,   189,   190,   191,
-	192,   193,   194,   195,   196,   197,   198,   199,   200,   201,   202,   203,   204,   205,   206,   207,
-	208,   209,   210,   211,   212,   213,   214,   215,   216,   217,   218,   219,   220,   221,   222,   223,
-	224,   225,   226,   227,   228,   229,   230,   231,   232,   233,   234,   235,   236,   237,   238,   239,
-	240,   241,   242,   243,   244,   245,   246,   247,   248,   249,   250,   251,   252,   253,   254,   255};
+void fillRGB(unsigned width, unsigned height, const XnUInt8* bayer_pixel, unsigned char* rgb_buffer, DebayeringMethod debayering_method, XnUInt32 nDownSampleStep)
+{
 
+	unsigned rgb_line_step = width * 3;
 //---------------------------------------------------------------------------
 // Code
+	unsigned rgb_line_skip = rgb_line_step - width * 3;
 //---------------------------------------------------------------------------
-void BayerUpdateGamma(float fGammaCorr)
+	if (nDownSampleStep == 1)
 {
-	for(XnUInt32 iG = 0; iG < 256;++iG)
-		Gamma[iG] = XnUInt8(255*pow(XnDouble(iG)/255.0,(XnDouble)fGammaCorr) + 0.5);
+		//register const XnUInt8 *bayer_pixel = image_md_->Data ();
+		register unsigned yIdx, xIdx;
+
+		int bayer_line_step = width;
+		int bayer_line_step2 = width << 1;
+
+		if (debayering_method == Bilinear)
+		{
+			// first two pixel values for first two lines
+			// Bayer         0 1 2
+			//         0     G r g
+			// line_step     b g b
+			// line_step2    g r g
+
+			rgb_buffer[3] = rgb_buffer[0] = bayer_pixel[1]; // red pixel
+			rgb_buffer[1] = bayer_pixel[0]; // green pixel
+			rgb_buffer[rgb_line_step + 2] = rgb_buffer[2] = bayer_pixel[bayer_line_step]; // blue;
+
+			// Bayer         0 1 2
+			//         0     g R g
+			// line_step     b g b
+			// line_step2    g r g
+			//rgb_pixel[3] = bayer_pixel[1];
+			rgb_buffer[4] = AVG3 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1]);
+			rgb_buffer[rgb_line_step + 5] = rgb_buffer[5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+
+			// BGBG line
+			// Bayer         0 1 2
+			//         0     g r g
+			// line_step     B g b
+			// line_step2    g r g
+			rgb_buffer[rgb_line_step + 3] = rgb_buffer[rgb_line_step ] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+			rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step + 1], bayer_pixel[bayer_line_step2]);
+			//rgb_pixel[rgb_line_step + 2] = bayer_pixel[line_step];
+
+			// pixel (1, 1)  0 1 2
+			//         0     g r g
+			// line_step     b G b
+			// line_step2    g r g
+			//rgb_pixel[rgb_line_step + 3] = AVG( bayer_pixel[1] , bayer_pixel[line_step2+1] );
+			rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+			//rgb_pixel[rgb_line_step + 5] = AVG( bayer_pixel[line_step] , bayer_pixel[line_step+2] );
+
+			rgb_buffer += 6;
+			bayer_pixel += 2;
+			// rest of the first two lines
+
+			for (xIdx = 2; xIdx < width - 2; xIdx += 2, rgb_buffer += 6, bayer_pixel += 2)
+			{
+				// GRGR line
+				// Bayer        -1 0 1 2
+				//           0   r G r g
+				//   line_step   g b g b
+				// line_step2    r g r g
+				rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+				rgb_buffer[1] = bayer_pixel[0];
+				rgb_buffer[2] = bayer_pixel[bayer_line_step + 1];
+
+				// Bayer        -1 0 1 2
+				//          0    r g R g
+				//  line_step    g b g b
+				// line_step2    r g r g
+				rgb_buffer[3] = bayer_pixel[1];
+				rgb_buffer[4] = AVG3 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1]);
+				rgb_buffer[rgb_line_step + 5] = rgb_buffer[5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+
+				// BGBG line
+				// Bayer         -1 0 1 2
+				//         0      r g r g
+				// line_step      g B g b
+				// line_step2     r g r g
+				rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+				rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+				rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+				// Bayer         -1 0 1 2
+				//         0      r g r g
+				// line_step      g b G b
+				// line_step2     r g r g
+				rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+				rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+				//rgb_pixel[rgb_line_step + 5] = AVG( bayer_pixel[line_step] , bayer_pixel[line_step+2] );
 }
 
-static inline void WriteRGB(XnUInt8 *pBuffer, XnUInt8 nRed, XnUInt8 nGreen, XnUInt8 nBlue)
+			// last two pixel values for first two lines
+			// GRGR line
+			// Bayer        -1 0 1
+			//           0   r G r
+			//   line_step   g b g
+			// line_step2    r g r
+			rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+			rgb_buffer[1] = bayer_pixel[0];
+			rgb_buffer[rgb_line_step + 5] = rgb_buffer[rgb_line_step + 2] = rgb_buffer[5] = rgb_buffer[2] = bayer_pixel[bayer_line_step];
+
+			// Bayer        -1 0 1
+			//          0    r g R
+			//  line_step    g b g
+			// line_step2    r g r
+			rgb_buffer[3] = bayer_pixel[1];
+			rgb_buffer[4] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step + 1]);
+			//rgb_pixel[5] = bayer_pixel[line_step];
+
+			// BGBG line
+			// Bayer        -1 0 1
+			//          0    r g r
+			//  line_step    g B g
+			// line_step2    r g r
+			rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+			rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+			//rgb_pixel[rgb_line_step + 2] = bayer_pixel[line_step];
+
+			// Bayer         -1 0 1
+			//         0      r g r
+			// line_step      g b G
+			// line_step2     r g r
+			rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+			rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+			//rgb_pixel[rgb_line_step + 5] = bayer_pixel[line_step];
+
+			bayer_pixel += bayer_line_step + 2;
+			rgb_buffer += rgb_line_step + 6 + rgb_line_skip;
+
+			// main processing
+
+			for (yIdx = 2; yIdx < height - 2; yIdx += 2)
 {
-	pBuffer[BAYER_RED] = Gamma[nRed];
-	pBuffer[BAYER_GREEN] = Gamma[nGreen];
-	pBuffer[BAYER_BLUE] = Gamma[nBlue];
+				// first two pixel values
+				// Bayer         0 1 2
+				//        -1     b g b
+				//         0     G r g
+				// line_step     b g b
+				// line_step2    g r g
+
+				rgb_buffer[3] = rgb_buffer[0] = bayer_pixel[1]; // red pixel
+				rgb_buffer[1] = bayer_pixel[0]; // green pixel
+				rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]); // blue;
+
+				// Bayer         0 1 2
+				//        -1     b g b
+				//         0     g R g
+				// line_step     b g b
+				// line_step2    g r g
+				//rgb_pixel[3] = bayer_pixel[1];
+				rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+				rgb_buffer[5] = AVG4 (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2], bayer_pixel[-bayer_line_step], bayer_pixel[2 - bayer_line_step]);
+
+				// BGBG line
+				// Bayer         0 1 2
+				//         0     g r g
+				// line_step     B g b
+				// line_step2    g r g
+				rgb_buffer[rgb_line_step + 3] = rgb_buffer[rgb_line_step ] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+				rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step + 1], bayer_pixel[bayer_line_step2]);
+				rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+				// pixel (1, 1)  0 1 2
+				//         0     g r g
+				// line_step     b G b
+				// line_step2    g r g
+				//rgb_pixel[rgb_line_step + 3] = AVG( bayer_pixel[1] , bayer_pixel[line_step2+1] );
+				rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+				rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+
+				rgb_buffer += 6;
+				bayer_pixel += 2;
+				// continue with rest of the line
+				for (xIdx = 2; xIdx < width - 2; xIdx += 2, rgb_buffer += 6, bayer_pixel += 2)
+				{
+					// GRGR line
+					// Bayer        -1 0 1 2
+					//          -1   g b g b
+					//           0   r G r g
+					//   line_step   g b g b
+					// line_step2    r g r g
+					rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+					rgb_buffer[1] = bayer_pixel[0];
+					rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]);
+
+					// Bayer        -1 0 1 2
+					//          -1   g b g b
+					//          0    r g R g
+					//  line_step    g b g b
+					// line_step2    r g r g
+					rgb_buffer[3] = bayer_pixel[1];
+					rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+					rgb_buffer[5] = AVG4 (bayer_pixel[-bayer_line_step], bayer_pixel[2 - bayer_line_step], bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+
+					// BGBG line
+					// Bayer         -1 0 1 2
+					//         -1     g b g b
+					//          0     r g r g
+					// line_step      g B g b
+					// line_step2     r g r g
+					rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+					rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+					rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+					// Bayer         -1 0 1 2
+					//         -1     g b g b
+					//          0     r g r g
+					// line_step      g b G b
+					// line_step2     r g r g
+					rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+					rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+					rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
 }
 
-void Bayer2RGB888(const XnUInt8* pBayerImage, XnUInt8* pRGBImage, XnUInt32 nXRes, XnUInt32 nYRes, XnUInt32 /*nDownSampleStep*/, XnUInt32 nBadPixels)
+				// last two pixels of the line
+				// last two pixel values for first two lines
+				// GRGR line
+				// Bayer        -1 0 1
+				//           0   r G r
+				//   line_step   g b g
+				// line_step2    r g r
+				rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+				rgb_buffer[1] = bayer_pixel[0];
+				rgb_buffer[rgb_line_step + 5] = rgb_buffer[rgb_line_step + 2] = rgb_buffer[5] = rgb_buffer[2] = bayer_pixel[bayer_line_step];
+
+				// Bayer        -1 0 1
+				//          0    r g R
+				//  line_step    g b g
+				// line_step2    r g r
+				rgb_buffer[3] = bayer_pixel[1];
+				rgb_buffer[4] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step + 1]);
+				//rgb_pixel[5] = bayer_pixel[line_step];
+
+				// BGBG line
+				// Bayer        -1 0 1
+				//          0    r g r
+				//  line_step    g B g
+				// line_step2    r g r
+				rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+				rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+				//rgb_pixel[rgb_line_step + 2] = bayer_pixel[line_step];
+
+				// Bayer         -1 0 1
+				//         0      r g r
+				// line_step      g b G
+				// line_step2     r g r
+				rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+				rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+				//rgb_pixel[rgb_line_step + 5] = bayer_pixel[line_step];
+
+				bayer_pixel += bayer_line_step + 2;
+				rgb_buffer += rgb_line_step + 6 + rgb_line_skip;
+			}
+
+			//last two lines
+			// Bayer         0 1 2
+			//        -1     b g b
+			//         0     G r g
+			// line_step     b g b
+
+			rgb_buffer[rgb_line_step + 3] = rgb_buffer[rgb_line_step ] = rgb_buffer[3] = rgb_buffer[0] = bayer_pixel[1]; // red pixel
+			rgb_buffer[1] = bayer_pixel[0]; // green pixel
+			rgb_buffer[rgb_line_step + 2] = rgb_buffer[2] = bayer_pixel[bayer_line_step]; // blue;
+
+			// Bayer         0 1 2
+			//        -1     b g b
+			//         0     g R g
+			// line_step     b g b
+			//rgb_pixel[3] = bayer_pixel[1];
+			rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+			rgb_buffer[5] = AVG4 (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2], bayer_pixel[-bayer_line_step], bayer_pixel[2 - bayer_line_step]);
+
+			// BGBG line
+			// Bayer         0 1 2
+			//        -1     b g b
+			//         0     g r g
+			// line_step     B g b
+			//rgb_pixel[rgb_line_step    ] = bayer_pixel[1];
+			rgb_buffer[rgb_line_step + 1] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step + 1]);
+			rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+			// Bayer         0 1 2
+			//        -1     b g b
+			//         0     g r g
+			// line_step     b G b
+			//rgb_pixel[rgb_line_step + 3] = AVG( bayer_pixel[1] , bayer_pixel[line_step2+1] );
+			rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+			rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+
+			rgb_buffer += 6;
+			bayer_pixel += 2;
+			// rest of the last two lines
+			for (xIdx = 2; xIdx < width - 2; xIdx += 2, rgb_buffer += 6, bayer_pixel += 2)
 {
-	XnUInt8 nRed;
-	XnUInt8 nGreen;
-	XnUInt8 nBlue;
-	const XnUInt8* pBayer;
-	XnUInt8* pRGB;
 
 	//if (nBadPixels > 1)
 	//{
 		//nBadPixels = 1;
 	//}
+				rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+				rgb_buffer[1] = bayer_pixel[0];
+				rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]);
+
+
+
+
+
+				rgb_buffer[rgb_line_step + 3] = rgb_buffer[3] = bayer_pixel[1];
+				rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+				rgb_buffer[5] = AVG4 (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2], bayer_pixel[-bayer_line_step], bayer_pixel[-bayer_line_step + 2]);
+
+
+
+
+
+
+				rgb_buffer[rgb_line_step ] = AVG (bayer_pixel[-1], bayer_pixel[1]);
+				rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+				rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+
+				// Bayer       -1 0 1 2
+				//        -1    g b g b
+				//         0    r g r g
+				// line_step    g b G b
+				//rgb_pixel[rgb_line_step + 3] = bayer_pixel[1];
+				rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+				rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+}
+
+			// last two pixel values for first two lines
+			// GRGR line
+			// Bayer       -1 0 1
+			//        -1    g b g
+			//         0    r G r
+			// line_step    g b g
+			rgb_buffer[rgb_line_step ] = rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+			rgb_buffer[1] = bayer_pixel[0];
+			rgb_buffer[5] = rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]);
+
+			// Bayer       -1 0 1
+			//        -1    g b g
+			//         0    r g R
+			// line_step    g b g
+			rgb_buffer[rgb_line_step + 3] = rgb_buffer[3] = bayer_pixel[1];
+			rgb_buffer[4] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step + 1], bayer_pixel[-bayer_line_step + 1]);
+			//rgb_pixel[5] = AVG( bayer_pixel[line_step], bayer_pixel[-line_step] );
+
+			// BGBG line
+			// Bayer       -1 0 1
+			//        -1    g b g
+			//         0    r g r
+			// line_step    g B g
+			//rgb_pixel[rgb_line_step    ] = AVG2( bayer_pixel[-1], bayer_pixel[1] );
+			rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+			rgb_buffer[rgb_line_step + 5] = rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+			// Bayer       -1 0 1
+			//        -1    g b g
+			//         0    r g r
+			// line_step    g b G
+			//rgb_pixel[rgb_line_step + 3] = bayer_pixel[1];
+			rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+			//rgb_pixel[rgb_line_step + 5] = bayer_pixel[line_step];
+		}
+		else if (debayering_method == EdgeAware)
+		{
+			int dh, dv;
+
+			// first two pixel values for first two lines
+			// Bayer         0 1 2
+			//         0     G r g
+			// line_step     b g b
+			// line_step2    g r g
+
+			rgb_buffer[3] = rgb_buffer[0] = bayer_pixel[1]; // red pixel
+			rgb_buffer[1] = bayer_pixel[0]; // green pixel
+			rgb_buffer[rgb_line_step + 2] = rgb_buffer[2] = bayer_pixel[bayer_line_step]; // blue;
+
+			// Bayer         0 1 2
+			//         0     g R g
+			// line_step     b g b
+			// line_step2    g r g
+			//rgb_pixel[3] = bayer_pixel[1];
+			rgb_buffer[4] = AVG3 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1]);
+			rgb_buffer[rgb_line_step + 5] = rgb_buffer[5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+
+			// BGBG line
+			// Bayer         0 1 2
+			//         0     g r g
+			// line_step     B g b
+			// line_step2    g r g
+			rgb_buffer[rgb_line_step + 3] = rgb_buffer[rgb_line_step ] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+			rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step + 1], bayer_pixel[bayer_line_step2]);
+			//rgb_pixel[rgb_line_step + 2] = bayer_pixel[line_step];
+
+			// pixel (1, 1)  0 1 2
+			//         0     g r g
+			// line_step     b G b
+			// line_step2    g r g
+			//rgb_pixel[rgb_line_step + 3] = AVG( bayer_pixel[1] , bayer_pixel[line_step2+1] );
+			rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+			//rgb_pixel[rgb_line_step + 5] = AVG( bayer_pixel[line_step] , bayer_pixel[line_step+2] );
+
+			rgb_buffer += 6;
+			bayer_pixel += 2;
+			// rest of the first two lines
+			for (xIdx = 2; xIdx < width - 2; xIdx += 2, rgb_buffer += 6, bayer_pixel += 2)
+			{
+				// GRGR line
+				// Bayer        -1 0 1 2
+				//           0   r G r g
+				//   line_step   g b g b
+				// line_step2    r g r g
+				rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+				rgb_buffer[1] = bayer_pixel[0];
+				rgb_buffer[2] = bayer_pixel[bayer_line_step + 1];
+
+				// Bayer        -1 0 1 2
+				//          0    r g R g
+				//  line_step    g b g b
+				// line_step2    r g r g
+				rgb_buffer[3] = bayer_pixel[1];
+				rgb_buffer[4] = AVG3 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1]);
+				rgb_buffer[rgb_line_step + 5] = rgb_buffer[5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+
+				// BGBG line
+				// Bayer         -1 0 1 2
+				//         0      r g r g
+				// line_step      g B g b
+				// line_step2     r g r g
+				rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+				rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+				rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+				// Bayer         -1 0 1 2
+				//         0      r g r g
+				// line_step      g b G b
+				// line_step2     r g r g
+				rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+				rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+				//rgb_pixel[rgb_line_step + 5] = AVG( bayer_pixel[line_step] , bayer_pixel[line_step+2] );
+			}
+
+			// last two pixel values for first two lines
+			// GRGR line
+			// Bayer        -1 0 1
+			//           0   r G r
+			//   line_step   g b g
+			// line_step2    r g r
+			rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+			rgb_buffer[1] = bayer_pixel[0];
+			rgb_buffer[rgb_line_step + 5] = rgb_buffer[rgb_line_step + 2] = rgb_buffer[5] = rgb_buffer[2] = bayer_pixel[bayer_line_step];
+
+			// Bayer        -1 0 1
+			//          0    r g R
+			//  line_step    g b g
+			// line_step2    r g r
+			rgb_buffer[3] = bayer_pixel[1];
+			rgb_buffer[4] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step + 1]);
+			//rgb_pixel[5] = bayer_pixel[line_step];
+
+			// BGBG line
+			// Bayer        -1 0 1
+			//          0    r g r
+			//  line_step    g B g
+			// line_step2    r g r
+			rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+			rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+			//rgb_pixel[rgb_line_step + 2] = bayer_pixel[line_step];
+
+			// Bayer         -1 0 1
+			//         0      r g r
+			// line_step      g b G
+			// line_step2     r g r
+			rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+			rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+			//rgb_pixel[rgb_line_step + 5] = bayer_pixel[line_step];
 
-	XnInt32 BAYER_LINE_LENGTH = nXRes;
-	XnInt32 BAYER_LINE_LENGTH2 = BAYER_LINE_LENGTH*2;
-	XnInt32 BAYER_RGB_LINE_LENGTH = nXRes*BAYER_BPP;
-	XnInt32 BAYER_RGB_LINE_LENGTH2 = BAYER_RGB_LINE_LENGTH*2;
+			bayer_pixel += bayer_line_step + 2;
+			rgb_buffer += rgb_line_step + 6 + rgb_line_skip;
+			// main processing
+			for (yIdx = 2; yIdx < height - 2; yIdx += 2)
+			{
+				// first two pixel values
+				// Bayer         0 1 2
+				//        -1     b g b
+				//         0     G r g
+				// line_step     b g b
+				// line_step2    g r g
 
-	const XnUInt8* pCurrBayer;
-	XnUInt8* pCurrRGB;
-	XnUInt32 nColCount;
-	XnUInt32 nTotalColsCount = (nXRes-2) / 2;
-	XnUInt32 nTotalRowsCount = (nYRes-4) / 2;
+				rgb_buffer[3] = rgb_buffer[0] = bayer_pixel[1]; // red pixel
+				rgb_buffer[1] = bayer_pixel[0]; // green pixel
+				rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]); // blue;
 
-	pBayer = pBayerImage + BAYER_LINE_LENGTH - nBadPixels;
-	pRGB = pRGBImage + BAYER_RGB_LINE_LENGTH;
+				// Bayer         0 1 2
+				//        -1     b g b
+				//         0     g R g
+				// line_step     b g b
+				// line_step2    g r g
+				//rgb_pixel[3] = bayer_pixel[1];
+				rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+				rgb_buffer[5] = AVG4 (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2], bayer_pixel[-bayer_line_step], bayer_pixel[2 - bayer_line_step]);
 
-	do {
-		pCurrBayer = pBayer+ 1;
-		pCurrRGB = pRGB + BAYER_BPP;
+				// BGBG line
+				// Bayer         0 1 2
+				//         0     g r g
+				// line_step     B g b
+				// line_step2    g r g
+				rgb_buffer[rgb_line_step + 3] = rgb_buffer[rgb_line_step ] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+				rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step + 1], bayer_pixel[bayer_line_step2]);
+				rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
 
-		nColCount = nTotalColsCount;
+				// pixel (1, 1)  0 1 2
+				//         0     g r g
+				// line_step     b G b
+				// line_step2    g r g
+				//rgb_pixel[rgb_line_step + 3] = AVG( bayer_pixel[1] , bayer_pixel[line_step2+1] );
+				rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+				rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
 
-		do {
+				rgb_buffer += 6;
+				bayer_pixel += 2;
+				// continue with rest of the line
+				for (xIdx = 2; xIdx < width - 2; xIdx += 2, rgb_buffer += 6, bayer_pixel += 2)
+				{
+					// GRGR line
+					// Bayer        -1 0 1 2
+					//          -1   g b g b
+					//           0   r G r g
+					//   line_step   g b g b
+					// line_step2    r g r g
+					rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+					rgb_buffer[1] = bayer_pixel[0];
+					rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]);
 
-			nRed   = ((XnUInt32)pCurrBayer[-BAYER_LINE_LENGTH]+pCurrBayer[BAYER_LINE_LENGTH]) / 2;
-			nBlue  = ((XnUInt32)pCurrBayer[-1]+pCurrBayer[1]) / 2;
-			WriteRGB(pCurrRGB+0, nRed, pCurrBayer[0], nBlue);
+					// Bayer        -1 0 1 2
+					//          -1   g b g b
+					//          0    r g R g
+					//  line_step    g b g b
+					// line_step2    r g r g
 
-			nRed   = ((XnUInt32)pCurrBayer[-BAYER_LINE_LENGTH+2]+pCurrBayer[BAYER_LINE_LENGTH+2]) / 2;
-			nGreen = ((XnUInt32)pCurrBayer[0]+pCurrBayer[2]) / 2;
-			WriteRGB(pCurrRGB+BAYER_BPP, nRed, nGreen, pCurrBayer[1]);
+					dh = abs (bayer_pixel[0] - bayer_pixel[2]);
+					dv = abs (bayer_pixel[-bayer_line_step + 1] - bayer_pixel[bayer_line_step + 1]);
 
-			nGreen = ((XnUInt32)pCurrBayer[BAYER_LINE_LENGTH-1]+pCurrBayer[BAYER_LINE_LENGTH+1]) / 2;
-			nBlue  = ((XnUInt32)pCurrBayer[BAYER_LINE_LENGTH2-1]+pCurrBayer[BAYER_LINE_LENGTH2+1]) / 2;
-			WriteRGB(pCurrRGB+BAYER_RGB_LINE_LENGTH, pCurrBayer[BAYER_LINE_LENGTH], nGreen, nBlue);
+					if (dh > dv)
+						rgb_buffer[4] = AVG (bayer_pixel[-bayer_line_step + 1], bayer_pixel[bayer_line_step + 1]);
+					else if (dv > dh)
+						rgb_buffer[4] = AVG (bayer_pixel[0], bayer_pixel[2]);
+					else
+						rgb_buffer[4] = AVG4 (bayer_pixel[-bayer_line_step + 1], bayer_pixel[bayer_line_step + 1], bayer_pixel[0], bayer_pixel[2]);
 
-			nRed   = ((XnUInt32)pCurrBayer[BAYER_LINE_LENGTH]+pCurrBayer[BAYER_LINE_LENGTH+2]) / 2;
-			nBlue  = ((XnUInt32)pCurrBayer[1]+pCurrBayer[BAYER_LINE_LENGTH2+1]) / 2;
-			WriteRGB(pCurrRGB+BAYER_RGB_LINE_LENGTH+BAYER_BPP, nRed, pCurrBayer[BAYER_LINE_LENGTH+1], nBlue);
+					rgb_buffer[3] = bayer_pixel[1];
+					rgb_buffer[5] = AVG4 (bayer_pixel[-bayer_line_step], bayer_pixel[2 - bayer_line_step], bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
 
-			pCurrBayer += 2;
-			pCurrRGB += 2*BAYER_BPP;
-		} while (--nColCount);
+					// BGBG line
+					// Bayer         -1 0 1 2
+					//         -1     g b g b
+					//          0     r g r g
+					// line_step      g B g b
+					// line_step2     r g r g
+					rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+					rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
 
-		pBayer += BAYER_LINE_LENGTH2;
-		pRGB += BAYER_RGB_LINE_LENGTH2;
-	} while (--nTotalRowsCount);
+					dv = abs (bayer_pixel[0] - bayer_pixel[bayer_line_step2]);
+					dh = abs (bayer_pixel[bayer_line_step - 1] - bayer_pixel[bayer_line_step + 1]);
+
+					if (dv > dh)
+						rgb_buffer[rgb_line_step + 1] = AVG (bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+					else if (dh > dv)
+						rgb_buffer[rgb_line_step + 1] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step2]);
+					else
+						rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+
+					// Bayer         -1 0 1 2
+					//         -1     g b g b
+					//          0     r g r g
+					// line_step      g b G b
+					// line_step2     r g r g
+					rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+					rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+					rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+				}
+
+				// last two pixels of the line
+				// last two pixel values for first two lines
+				// GRGR line
+				// Bayer        -1 0 1
+				//           0   r G r
+				//   line_step   g b g
+				// line_step2    r g r
+				rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+				rgb_buffer[1] = bayer_pixel[0];
+				rgb_buffer[rgb_line_step + 5] = rgb_buffer[rgb_line_step + 2] = rgb_buffer[5] = rgb_buffer[2] = bayer_pixel[bayer_line_step];
+
+				// Bayer        -1 0 1
+				//          0    r g R
+				//  line_step    g b g
+				// line_step2    r g r
+				rgb_buffer[3] = bayer_pixel[1];
+				rgb_buffer[4] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step + 1]);
+				//rgb_pixel[5] = bayer_pixel[line_step];
+
+				// BGBG line
+				// Bayer        -1 0 1
+				//          0    r g r
+				//  line_step    g B g
+				// line_step2    r g r
+				rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+				rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+				//rgb_pixel[rgb_line_step + 2] = bayer_pixel[line_step];
+
+				// Bayer         -1 0 1
+				//         0      r g r
+				// line_step      g b G
+				// line_step2     r g r
+				rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+				rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+				//rgb_pixel[rgb_line_step + 5] = bayer_pixel[line_step];
+
+				bayer_pixel += bayer_line_step + 2;
+				rgb_buffer += rgb_line_step + 6 + rgb_line_skip;
+			}
+
+			//last two lines
+			// Bayer         0 1 2
+			//        -1     b g b
+			//         0     G r g
+			// line_step     b g b
+
+			rgb_buffer[rgb_line_step + 3] = rgb_buffer[rgb_line_step ] = rgb_buffer[3] = rgb_buffer[0] = bayer_pixel[1]; // red pixel
+			rgb_buffer[1] = bayer_pixel[0]; // green pixel
+			rgb_buffer[rgb_line_step + 2] = rgb_buffer[2] = bayer_pixel[bayer_line_step]; // blue;
+
+			// Bayer         0 1 2
+			//        -1     b g b
+			//         0     g R g
+			// line_step     b g b
+			//rgb_pixel[3] = bayer_pixel[1];
+			rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+			rgb_buffer[5] = AVG4 (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2], bayer_pixel[-bayer_line_step], bayer_pixel[2 - bayer_line_step]);
+
+			// BGBG line
+			// Bayer         0 1 2
+			//        -1     b g b
+			//         0     g r g
+			// line_step     B g b
+			//rgb_pixel[rgb_line_step    ] = bayer_pixel[1];
+			rgb_buffer[rgb_line_step + 1] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step + 1]);
+			rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+			// Bayer         0 1 2
+			//        -1     b g b
+			//         0     g r g
+			// line_step     b G b
+			//rgb_pixel[rgb_line_step + 3] = AVG( bayer_pixel[1] , bayer_pixel[line_step2+1] );
+			rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+			rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+
+			rgb_buffer += 6;
+			bayer_pixel += 2;
+			// rest of the last two lines
+			for (xIdx = 2; xIdx < width - 2; xIdx += 2, rgb_buffer += 6, bayer_pixel += 2)
+			{
+				// GRGR line
+				// Bayer       -1 0 1 2
+				//        -1    g b g b
+				//         0    r G r g
+				// line_step    g b g b
+				rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+				rgb_buffer[1] = bayer_pixel[0];
+				rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]);
+
+				// Bayer       -1 0 1 2
+				//        -1    g b g b
+				//         0    r g R g
+				// line_step    g b g b
+				rgb_buffer[rgb_line_step + 3] = rgb_buffer[3] = bayer_pixel[1];
+				rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+				rgb_buffer[5] = AVG4 (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2], bayer_pixel[-bayer_line_step], bayer_pixel[-bayer_line_step + 2]);
+
+				// BGBG line
+				// Bayer       -1 0 1 2
+				//        -1    g b g b
+				//         0    r g r g
+				// line_step    g B g b
+				rgb_buffer[rgb_line_step ] = AVG (bayer_pixel[-1], bayer_pixel[1]);
+				rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+				rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+
+				// Bayer       -1 0 1 2
+				//        -1    g b g b
+				//         0    r g r g
+				// line_step    g b G b
+				//rgb_pixel[rgb_line_step + 3] = bayer_pixel[1];
+				rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+				rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+			}
+
+			// last two pixel values for first two lines
+			// GRGR line
+			// Bayer       -1 0 1
+			//        -1    g b g
+			//         0    r G r
+			// line_step    g b g
+			rgb_buffer[rgb_line_step ] = rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+			rgb_buffer[1] = bayer_pixel[0];
+			rgb_buffer[5] = rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]);
+
+			// Bayer       -1 0 1
+			//        -1    g b g
+			//         0    r g R
+			// line_step    g b g
+			rgb_buffer[rgb_line_step + 3] = rgb_buffer[3] = bayer_pixel[1];
+			rgb_buffer[4] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step + 1], bayer_pixel[-bayer_line_step + 1]);
+			//rgb_pixel[5] = AVG( bayer_pixel[line_step], bayer_pixel[-line_step] );
+
+			// BGBG line
+			// Bayer       -1 0 1
+			//        -1    g b g
+			//         0    r g r
+			// line_step    g B g
+			//rgb_pixel[rgb_line_step    ] = AVG2( bayer_pixel[-1], bayer_pixel[1] );
+			rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+			rgb_buffer[rgb_line_step + 5] = rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+			// Bayer       -1 0 1
+			//        -1    g b g
+			//         0    r g r
+			// line_step    g b G
+			//rgb_pixel[rgb_line_step + 3] = bayer_pixel[1];
+			rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+			//rgb_pixel[rgb_line_step + 5] = bayer_pixel[line_step];
+		}
+		else if (debayering_method == EdgeAwareWeighted)
+		{
+			int dh, dv;
+
+			// first two pixel values for first two lines
+			// Bayer         0 1 2
+			//         0     G r g
+			// line_step     b g b
+			// line_step2    g r g
+
+			rgb_buffer[3] = rgb_buffer[0] = bayer_pixel[1]; // red pixel
+			rgb_buffer[1] = bayer_pixel[0]; // green pixel
+			rgb_buffer[rgb_line_step + 2] = rgb_buffer[2] = bayer_pixel[bayer_line_step]; // blue;
+
+			// Bayer         0 1 2
+			//         0     g R g
+			// line_step     b g b
+			// line_step2    g r g
+			//rgb_pixel[3] = bayer_pixel[1];
+			rgb_buffer[4] = AVG3 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1]);
+			rgb_buffer[rgb_line_step + 5] = rgb_buffer[5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+
+			// BGBG line
+			// Bayer         0 1 2
+			//         0     g r g
+			// line_step     B g b
+			// line_step2    g r g
+			rgb_buffer[rgb_line_step + 3] = rgb_buffer[rgb_line_step ] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+			rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step + 1], bayer_pixel[bayer_line_step2]);
+			//rgb_pixel[rgb_line_step + 2] = bayer_pixel[line_step];
+
+			// pixel (1, 1)  0 1 2
+			//         0     g r g
+			// line_step     b G b
+			// line_step2    g r g
+			//rgb_pixel[rgb_line_step + 3] = AVG( bayer_pixel[1] , bayer_pixel[line_step2+1] );
+			rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+			//rgb_pixel[rgb_line_step + 5] = AVG( bayer_pixel[line_step] , bayer_pixel[line_step+2] );
+
+			rgb_buffer += 6;
+			bayer_pixel += 2;
+			// rest of the first two lines
+			for (xIdx = 2; xIdx < width - 2; xIdx += 2, rgb_buffer += 6, bayer_pixel += 2)
+			{
+				// GRGR line
+				// Bayer        -1 0 1 2
+				//           0   r G r g
+				//   line_step   g b g b
+				// line_step2    r g r g
+				rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+				rgb_buffer[1] = bayer_pixel[0];
+				rgb_buffer[2] = bayer_pixel[bayer_line_step + 1];
+
+				// Bayer        -1 0 1 2
+				//          0    r g R g
+				//  line_step    g b g b
+				// line_step2    r g r g
+				rgb_buffer[3] = bayer_pixel[1];
+				rgb_buffer[4] = AVG3 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1]);
+				rgb_buffer[rgb_line_step + 5] = rgb_buffer[5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+
+				// BGBG line
+				// Bayer         -1 0 1 2
+				//         0      r g r g
+				// line_step      g B g b
+				// line_step2     r g r g
+				rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+				rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+				rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+				// Bayer         -1 0 1 2
+				//         0      r g r g
+				// line_step      g b G b
+				// line_step2     r g r g
+				rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+				rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+				//rgb_pixel[rgb_line_step + 5] = AVG( bayer_pixel[line_step] , bayer_pixel[line_step+2] );
+			}
+
+			// last two pixel values for first two lines
+			// GRGR line
+			// Bayer        -1 0 1
+			//           0   r G r
+			//   line_step   g b g
+			// line_step2    r g r
+			rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+			rgb_buffer[1] = bayer_pixel[0];
+			rgb_buffer[rgb_line_step + 5] = rgb_buffer[rgb_line_step + 2] = rgb_buffer[5] = rgb_buffer[2] = bayer_pixel[bayer_line_step];
+
+			// Bayer        -1 0 1
+			//          0    r g R
+			//  line_step    g b g
+			// line_step2    r g r
+			rgb_buffer[3] = bayer_pixel[1];
+			rgb_buffer[4] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step + 1]);
+			//rgb_pixel[5] = bayer_pixel[line_step];
+
+			// BGBG line
+			// Bayer        -1 0 1
+			//          0    r g r
+			//  line_step    g B g
+			// line_step2    r g r
+			rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+			rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+			//rgb_pixel[rgb_line_step + 2] = bayer_pixel[line_step];
+
+			// Bayer         -1 0 1
+			//         0      r g r
+			// line_step      g b G
+			// line_step2     r g r
+			rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+			rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+			//rgb_pixel[rgb_line_step + 5] = bayer_pixel[line_step];
+
+			bayer_pixel += bayer_line_step + 2;
+			rgb_buffer += rgb_line_step + 6 + rgb_line_skip;
+			// main processing
+			for (yIdx = 2; yIdx < height - 2; yIdx += 2)
+			{
+				// first two pixel values
+				// Bayer         0 1 2
+				//        -1     b g b
+				//         0     G r g
+				// line_step     b g b
+				// line_step2    g r g
+
+				rgb_buffer[3] = rgb_buffer[0] = bayer_pixel[1]; // red pixel
+				rgb_buffer[1] = bayer_pixel[0]; // green pixel
+				rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]); // blue;
+
+				// Bayer         0 1 2
+				//        -1     b g b
+				//         0     g R g
+				// line_step     b g b
+				// line_step2    g r g
+				//rgb_pixel[3] = bayer_pixel[1];
+				rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+				rgb_buffer[5] = AVG4 (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2], bayer_pixel[-bayer_line_step], bayer_pixel[2 - bayer_line_step]);
+
+				// BGBG line
+				// Bayer         0 1 2
+				//         0     g r g
+				// line_step     B g b
+				// line_step2    g r g
+				rgb_buffer[rgb_line_step + 3] = rgb_buffer[rgb_line_step ] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+				rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step + 1], bayer_pixel[bayer_line_step2]);
+				rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+				// pixel (1, 1)  0 1 2
+				//         0     g r g
+				// line_step     b G b
+				// line_step2    g r g
+				//rgb_pixel[rgb_line_step + 3] = AVG( bayer_pixel[1] , bayer_pixel[line_step2+1] );
+				rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+				rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+
+				rgb_buffer += 6;
+				bayer_pixel += 2;
+				// continue with rest of the line
+				for (xIdx = 2; xIdx < width - 2; xIdx += 2, rgb_buffer += 6, bayer_pixel += 2)
+				{
+					// GRGR line
+					// Bayer        -1 0 1 2
+					//          -1   g b g b
+					//           0   r G r g
+					//   line_step   g b g b
+					// line_step2    r g r g
+					rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+					rgb_buffer[1] = bayer_pixel[0];
+					rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]);
+
+					// Bayer        -1 0 1 2
+					//          -1   g b g b
+					//          0    r g R g
+					//  line_step    g b g b
+					// line_step2    r g r g
+
+					dh = abs (bayer_pixel[0] - bayer_pixel[2]);
+					dv = abs (bayer_pixel[-bayer_line_step + 1] - bayer_pixel[bayer_line_step + 1]);
+
+					if (dv == 0 && dh == 0)
+						rgb_buffer[4] = AVG4 (bayer_pixel[1 - bayer_line_step], bayer_pixel[1 + bayer_line_step], bayer_pixel[0], bayer_pixel[2]);
+					else
+						rgb_buffer[4] = WAVG4 (bayer_pixel[1 - bayer_line_step], bayer_pixel[1 + bayer_line_step], bayer_pixel[0], bayer_pixel[2], dh, dv);
+					rgb_buffer[3] = bayer_pixel[1];
+					rgb_buffer[5] = AVG4 (bayer_pixel[-bayer_line_step], bayer_pixel[2 - bayer_line_step], bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+
+					// BGBG line
+					// Bayer         -1 0 1 2
+					//         -1     g b g b
+					//          0     r g r g
+					// line_step      g B g b
+					// line_step2     r g r g
+					rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+					rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+					dv = abs (bayer_pixel[0] - bayer_pixel[bayer_line_step2]);
+					dh = abs (bayer_pixel[bayer_line_step - 1] - bayer_pixel[bayer_line_step + 1]);
+
+					if (dv == 0 && dh == 0)
+						rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+					else
+						rgb_buffer[rgb_line_step + 1] = WAVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1], dh, dv);
+
+					// Bayer         -1 0 1 2
+					//         -1     g b g b
+					//          0     r g r g
+					// line_step      g b G b
+					// line_step2     r g r g
+					rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+					rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+					rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+				}
+
+				// last two pixels of the line
+				// last two pixel values for first two lines
+				// GRGR line
+				// Bayer        -1 0 1
+				//           0   r G r
+				//   line_step   g b g
+				// line_step2    r g r
+				rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+				rgb_buffer[1] = bayer_pixel[0];
+				rgb_buffer[rgb_line_step + 5] = rgb_buffer[rgb_line_step + 2] = rgb_buffer[5] = rgb_buffer[2] = bayer_pixel[bayer_line_step];
+
+				// Bayer        -1 0 1
+				//          0    r g R
+				//  line_step    g b g
+				// line_step2    r g r
+				rgb_buffer[3] = bayer_pixel[1];
+				rgb_buffer[4] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step + 1]);
+				//rgb_pixel[5] = bayer_pixel[line_step];
+
+				// BGBG line
+				// Bayer        -1 0 1
+				//          0    r g r
+				//  line_step    g B g
+				// line_step2    r g r
+				rgb_buffer[rgb_line_step ] = AVG4 (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1], bayer_pixel[-1], bayer_pixel[bayer_line_step2 - 1]);
+				rgb_buffer[rgb_line_step + 1] = AVG4 (bayer_pixel[0], bayer_pixel[bayer_line_step2], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+				//rgb_pixel[rgb_line_step + 2] = bayer_pixel[line_step];
+
+				// Bayer         -1 0 1
+				//         0      r g r
+				// line_step      g b G
+				// line_step2     r g r
+				rgb_buffer[rgb_line_step + 3] = AVG (bayer_pixel[1], bayer_pixel[bayer_line_step2 + 1]);
+				rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+				//rgb_pixel[rgb_line_step + 5] = bayer_pixel[line_step];
+
+				bayer_pixel += bayer_line_step + 2;
+				rgb_buffer += rgb_line_step + 6 + rgb_line_skip;
+			}
+
+			//last two lines
+			// Bayer         0 1 2
+			//        -1     b g b
+			//         0     G r g
+			// line_step     b g b
+
+			rgb_buffer[rgb_line_step + 3] = rgb_buffer[rgb_line_step ] = rgb_buffer[3] = rgb_buffer[0] = bayer_pixel[1]; // red pixel
+			rgb_buffer[1] = bayer_pixel[0]; // green pixel
+			rgb_buffer[rgb_line_step + 2] = rgb_buffer[2] = bayer_pixel[bayer_line_step]; // blue;
+
+			// Bayer         0 1 2
+			//        -1     b g b
+			//         0     g R g
+			// line_step     b g b
+			//rgb_pixel[3] = bayer_pixel[1];
+			rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+			rgb_buffer[5] = AVG4 (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2], bayer_pixel[-bayer_line_step], bayer_pixel[2 - bayer_line_step]);
+
+			// BGBG line
+			// Bayer         0 1 2
+			//        -1     b g b
+			//         0     g r g
+			// line_step     B g b
+			//rgb_pixel[rgb_line_step    ] = bayer_pixel[1];
+			rgb_buffer[rgb_line_step + 1] = AVG (bayer_pixel[0], bayer_pixel[bayer_line_step + 1]);
+			rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+			// Bayer         0 1 2
+			//        -1     b g b
+			//         0     g r g
+			// line_step     b G b
+			//rgb_pixel[rgb_line_step + 3] = AVG( bayer_pixel[1] , bayer_pixel[line_step2+1] );
+			rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+			rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+
+			rgb_buffer += 6;
+			bayer_pixel += 2;
+			// rest of the last two lines
+			for (xIdx = 2; xIdx < width - 2; xIdx += 2, rgb_buffer += 6, bayer_pixel += 2)
+			{
+				// GRGR line
+				// Bayer       -1 0 1 2
+				//        -1    g b g b
+				//         0    r G r g
+				// line_step    g b g b
+				rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+				rgb_buffer[1] = bayer_pixel[0];
+				rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]);
+
+				// Bayer       -1 0 1 2
+				//        -1    g b g b
+				//         0    r g R g
+				// line_step    g b g b
+				rgb_buffer[rgb_line_step + 3] = rgb_buffer[3] = bayer_pixel[1];
+				rgb_buffer[4] = AVG4 (bayer_pixel[0], bayer_pixel[2], bayer_pixel[bayer_line_step + 1], bayer_pixel[1 - bayer_line_step]);
+				rgb_buffer[5] = AVG4 (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2], bayer_pixel[-bayer_line_step], bayer_pixel[-bayer_line_step + 2]);
+
+				// BGBG line
+				// Bayer       -1 0 1 2
+				//        -1    g b g b
+				//         0    r g r g
+				// line_step    g B g b
+				rgb_buffer[rgb_line_step ] = AVG (bayer_pixel[-1], bayer_pixel[1]);
+				rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+				rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+
+				// Bayer       -1 0 1 2
+				//        -1    g b g b
+				//         0    r g r g
+				// line_step    g b G b
+				//rgb_pixel[rgb_line_step + 3] = bayer_pixel[1];
+				rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+				rgb_buffer[rgb_line_step + 5] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[bayer_line_step + 2]);
+			}
+
+			// last two pixel values for first two lines
+			// GRGR line
+			// Bayer       -1 0 1
+			//        -1    g b g
+			//         0    r G r
+			// line_step    g b g
+			rgb_buffer[rgb_line_step ] = rgb_buffer[0] = AVG (bayer_pixel[1], bayer_pixel[-1]);
+			rgb_buffer[1] = bayer_pixel[0];
+			rgb_buffer[5] = rgb_buffer[2] = AVG (bayer_pixel[bayer_line_step], bayer_pixel[-bayer_line_step]);
+
+			// Bayer       -1 0 1
+			//        -1    g b g
+			//         0    r g R
+			// line_step    g b g
+			rgb_buffer[rgb_line_step + 3] = rgb_buffer[3] = bayer_pixel[1];
+			rgb_buffer[4] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step + 1], bayer_pixel[-bayer_line_step + 1]);
+			//rgb_pixel[5] = AVG( bayer_pixel[line_step], bayer_pixel[-line_step] );
+
+			// BGBG line
+			// Bayer       -1 0 1
+			//        -1    g b g
+			//         0    r g r
+			// line_step    g B g
+			//rgb_pixel[rgb_line_step    ] = AVG2( bayer_pixel[-1], bayer_pixel[1] );
+			rgb_buffer[rgb_line_step + 1] = AVG3 (bayer_pixel[0], bayer_pixel[bayer_line_step - 1], bayer_pixel[bayer_line_step + 1]);
+			rgb_buffer[rgb_line_step + 5] = rgb_buffer[rgb_line_step + 2] = bayer_pixel[bayer_line_step];
+
+			// Bayer       -1 0 1
+			//        -1    g b g
+			//         0    r g r
+			// line_step    g b G
+			//rgb_pixel[rgb_line_step + 3] = bayer_pixel[1];
+			rgb_buffer[rgb_line_step + 4] = bayer_pixel[bayer_line_step + 1];
+			//rgb_pixel[rgb_line_step + 5] = bayer_pixel[line_step];
+		}
+		//else
+		//	THROW_OPENNI_EXCEPTION ("Unknwon debayering method: %d", (int)debayering_method);
+	}
+	//Warning: Downsampling mod is untested
+	else if (nDownSampleStep > 1)
+	{
+		// get each or each 2nd pixel group to find rgb values!
+		register unsigned bayerXStep = nDownSampleStep;
+		register unsigned bayerYSkip = (nDownSampleStep - 1) * width;
+
+		// Downsampling and debayering at once
+		register const XnUInt8* bayer_buffer = bayer_pixel;
+
+		for (register unsigned yIdx = 0; yIdx < height; ++yIdx, bayer_buffer += bayerYSkip, rgb_buffer += rgb_line_skip) // skip a line
+		{
+			for (register unsigned xIdx = 0; xIdx < width; ++xIdx, rgb_buffer += 3, bayer_buffer += bayerXStep)
+			{
+				rgb_buffer[ 2 ] = bayer_buffer[ width ];
+				rgb_buffer[ 1 ] = AVG (bayer_buffer[0], bayer_buffer[ width + 1]);
+				rgb_buffer[ 0 ] = bayer_buffer[ 1 ];
+			}
+		}
+	}
+}
+
+
+
+void Bayer2RGB888(const XnUInt8* pBayerImage, XnUInt8* pRGBImage, XnUInt32 nXRes, XnUInt32 nYRes, XnUInt32 nDownSampleStep, XnUInt32 nBadPixels)
+{
+	fillRGB(nXRes, nYRes, pBayerImage, pRGBImage, DebayeringMethod(1), nDownSampleStep); // DebayeringMethod(0) == bilinear, (1) == edge aware, (2) == edge aware weighted
 }
diff --git a/Source/XnDeviceSensorV2/Registration.cpp b/Source/XnDeviceSensorV2/Registration.cpp
index 49f1925..5c10a98 100644
--- a/Source/XnDeviceSensorV2/Registration.cpp
+++ b/Source/XnDeviceSensorV2/Registration.cpp
@@ -55,7 +55,7 @@ inline XnDouble XnXRegistrationFunction1000(XnRegistrationInformation1000& regIn
 		regInfo1000.FuncX.dD,
 		regInfo1000.FuncX.dE,
 		regInfo1000.FuncX.dF,
-		(XnUInt16)(nX - nXRes/2), 
+		(XnUInt16)(nX - nXRes/2),
 		(XnUInt16)(nY - nYRes/2));
 }
 
@@ -68,19 +68,19 @@ inline XnDouble XnYRegistrationFunction1000(XnRegistrationInformation1000& regIn
 		regInfo1000.FuncY.dD,
 		regInfo1000.FuncY.dE,
 		regInfo1000.FuncY.dF,
-		(XnUInt16)(nX - nXRes/2), 
+		(XnUInt16)(nX - nXRes/2),
 		(XnUInt16)(nY - nYRes/2));
 }
 
 XnStatus XnRegistration::BuildRegTable1000()
 {
 	XnStatus nRetVal = XN_STATUS_OK;
-	
+
 	// take needed parameters to perform registration
 	XnRegistrationInformation1000 regInfo1000;
 	nRetVal = XnHostProtocolAlgorithmParams(m_pDevicePrivateData, XN_HOST_PROTOCOL_ALGORITHM_REGISTRATION, &regInfo1000, sizeof(regInfo1000), m_pDepthStream->GetResolution(), (XnUInt16)m_pDepthStream->GetFPS());
 	XN_IS_STATUS_OK(nRetVal);
-	
+
 	XnUInt16* pRegTable = m_pRegistrationTable;
 	XnDouble dDeltaX, dDeltaY;
 
@@ -234,7 +234,7 @@ void CreateDXDYTables (XnDouble* RegXTable, XnDouble* RegYTable,
 void BuildDepthToShiftTable(XnUInt16* pDepth2Shift, XnSensorDepthStream* m_pStream)
 {
 	XnUInt32 nXScale = XN_CMOS_VGAOUTPUT_XRES / XN_DEPTH_XRES;
-	XnInt16* pRGBRegDepthToShiftTable = (XnInt16*)pDepth2Shift; 
+	XnInt16* pRGBRegDepthToShiftTable = (XnInt16*)pDepth2Shift;
 	XnUInt32 nIndex = 0;
 	XnDouble dDepth = 0;
 
@@ -248,10 +248,8 @@ void BuildDepthToShiftTable(XnUInt16* pDepth2Shift, XnSensorDepthStream* m_pStre
 	m_pStream->GetProperty(XN_STREAM_PROPERTY_ZERO_PLANE_DISTANCE, &nPlaneDsr);
 	dPlaneDsr = (XnDouble)nPlaneDsr;
 
-	XnUInt64 nDCRCDist;
 	XnDouble dDCRCDist;
-	m_pStream->GetProperty(XN_STREAM_PROPERTY_DCMOS_RCMOS_DISTANCE, &nDCRCDist);
-	dDCRCDist = (XnDouble)nDCRCDist;
+	m_pStream->GetProperty(XN_STREAM_PROPERTY_DCMOS_RCMOS_DISTANCE, &dDCRCDist);
 
 	XnDouble dPelSize = 1.0 / (dPlanePixelSize * nXScale * S2D_PEL_CONST);
 	XnDouble dPelDCC = dDCRCDist * dPelSize * S2D_PEL_CONST;
@@ -269,7 +267,7 @@ void BuildDepthToShiftTable(XnUInt16* pDepth2Shift, XnSensorDepthStream* m_pStre
 XnStatus XnRegistration::BuildRegTable1080()
 {
 	XnStatus nRetVal = XN_STATUS_OK;
-	
+
 	// take needed parameters to perform registration
 	XnRegistrationInformation1080 RegData;
 	nRetVal = XnHostProtocolAlgorithmParams(m_pDevicePrivateData, XN_HOST_PROTOCOL_ALGORITHM_REGISTRATION, &RegData, sizeof(RegData), m_pDepthStream->GetResolution(), (XnUInt16)m_pDepthStream->GetFPS());
@@ -361,7 +359,7 @@ XnStatus XnRegistration::BuildRegTable1080()
 FinishLoop:
 	XN_DELETE_ARR(RegXTable);
 	XN_DELETE_ARR(RegYTable);
-	
+
 	return (XN_STATUS_OK);
 }
 
@@ -472,13 +470,28 @@ void XnRegistration::Apply1000(XnDepthPixel* pInput, XnDepthPixel* pOutput)
 			nNewX = (XnInt32)(XnDouble(*pRegTable)/XN_REG_X_SCALE + XnInt32(pDepth2ShiftTable[nValue]/XN_REG_PARAB_COEFF - nConstShift) * dShiftFactor);
 			nNewY = *(pRegTable+1);
 
-			if ((XnUInt32)nNewX-1 < (XnUInt32)nDepthXRes-1)
+			if ((XnUInt32)nNewX-1 < (XnUInt32)nDepthXRes-1 && (XnUInt32)nNewY <(XnUInt32) nDepthYRes)
 			{
 				nArrPos = nNewY * nDepthXRes + nNewX;
 				nOutValue = pOutput[nArrPos];
 
 				if (nOutValue == 0 || nOutValue > nValue)
 				{
+				  if ( nNewX > 0 && nNewY > 0 )
+					{
+						pOutput[nArrPos-nDepthXRes] = nValue;
+						pOutput[nArrPos-nDepthXRes-1] = nValue;
+						pOutput[nArrPos-1] = nValue;
+					}
+					else if( nNewY > 0 )
+					{
+						pOutput[nArrPos-nDepthXRes] = nValue;
+					}
+					else if( nNewX > 0 )
+					{
+						pOutput[nArrPos-1] = nValue;
+					}
+
 					pOutput[nArrPos] = nValue;
 					pOutput[nArrPos-1] = nValue;
 					pOutput[nArrPos-nDepthXRes] = nValue;
@@ -495,7 +508,7 @@ void XnRegistration::Apply1000(XnDepthPixel* pInput, XnDepthPixel* pOutput)
 void XnRegistration::Apply1080(XnDepthPixel* pInput, XnDepthPixel* pOutput)
 {
 	XnInt16* pRegTable = (XnInt16*)m_pRegistrationTable;
-	XnInt16* pRGBRegDepthToShiftTable = (XnInt16*)m_pDepthToShiftTable; 
+	XnInt16* pRGBRegDepthToShiftTable = (XnInt16*)m_pDepthToShiftTable;
 	XnDepthPixel nValue = 0;
 	XnDepthPixel nOutValue = 0;
 	XnUInt32 nNewX = 0;
@@ -523,11 +536,11 @@ void XnRegistration::Apply1080(XnDepthPixel* pInput, XnDepthPixel* pOutput)
 				nNewX = (XnUInt32)(*pRegTable + pRGBRegDepthToShiftTable[nValue]) / RGB_REG_X_VAL_SCALE;
 				nNewY = *(pRegTable+1);
 
-				if (nNewX < nDepthXRes)
+				if (nNewX < nDepthXRes && nNewY < nDepthYRes)
 				{
 					nArrPos = bMirror ? (nNewY+1)*nDepthXRes - nNewX : (nNewY*nDepthXRes) + nNewX;
 					nArrPos -= nConstOffset;
-					
+
 					nOutValue = pOutput[nArrPos];
 
 					if ((nOutValue == XN_DEVICE_SENSOR_NO_DEPTH_VALUE) || (nOutValue > nValue))
diff --git a/Source/XnDeviceSensorV2/XnDataProcessor.h b/Source/XnDeviceSensorV2/XnDataProcessor.h
index 49e045d..7301837 100644
--- a/Source/XnDeviceSensorV2/XnDataProcessor.h
+++ b/Source/XnDeviceSensorV2/XnDataProcessor.h
@@ -86,7 +86,8 @@ protected:
 	/* The number of bytes received so far (since last time this member was reset). */
 	XnUInt32 m_nBytesReceived;
 	/* Stores last packet ID */
-	XnUInt16 m_nLastPacketID;
+	// --avin mod--
+  XnUInt8  m_nLastPacketID;
 	/* The name of the stream. */
 	const XnChar* m_csName;
 
diff --git a/Source/XnDeviceSensorV2/XnDeviceSensorIO.cpp b/Source/XnDeviceSensorV2/XnDeviceSensorIO.cpp
index 6b01050..13c16e0 100644
--- a/Source/XnDeviceSensorV2/XnDeviceSensorIO.cpp
+++ b/Source/XnDeviceSensorV2/XnDeviceSensorIO.cpp
@@ -27,14 +27,6 @@
 #include <XnStringsHash.h>
 
 //---------------------------------------------------------------------------
-// Defines
-//---------------------------------------------------------------------------
-#define XN_SENSOR_VENDOR_ID			0x1D27
-#define XN_SENSOR_5_0_PRODUCT_ID	0x0500
-#define XN_SENSOR_6_0_PRODUCT_ID	0x0600
-#define XN_SENSOR_6_0_1_PRODUCT_ID	0x0601
-
-//---------------------------------------------------------------------------
 // Enums
 //---------------------------------------------------------------------------
 typedef enum
@@ -147,9 +139,11 @@ XnStatus XnSensorIO::OpenDataEndPoints(XnSensorUsbInterface nInterface, const Xn
 			XN_LOG_WARNING_RETURN(XN_STATUS_USB_INTERFACE_NOT_SUPPORTED, XN_MASK_DEVICE_IO, "Unknown interface type: %d", nInterface);
 		}
 
+/*
 		xnLogVerbose(XN_MASK_DEVICE_IO, "Setting USB alternative interface to %d...", nAlternativeInterface);
 		nRetVal = xnUSBSetInterface(m_pSensorHandle->USBDevice, 0, nAlternativeInterface);
 		XN_IS_STATUS_OK(nRetVal);
+*/
 	}
 
 	xnLogVerbose(XN_MASK_DEVICE_IO, "Opening endpoints...");
@@ -356,14 +350,14 @@ XnStatus XnSensorIO::CloseDevice()
 	return (XN_STATUS_OK);
 }
 
-XnStatus Enumerate(XnUInt16 nProduct, XnStringsHash& devicesSet)
+XnStatus Enumerate(XnUInt16 nVendor, XnUInt16 nProduct, XnStringsHash& devicesSet)
 {
 	XnStatus nRetVal = XN_STATUS_OK;
 	
 	const XnUSBConnectionString* astrDevicePaths;
 	XnUInt32 nCount;
 
-	nRetVal = xnUSBEnumerateDevices(XN_SENSOR_VENDOR_ID, nProduct, &astrDevicePaths, &nCount);
+	nRetVal = xnUSBEnumerateDevices(nVendor, nProduct, &astrDevicePaths, &nCount);
 	XN_IS_STATUS_OK(nRetVal);
 
 	for (XnUInt32 i = 0; i < nCount; ++i)
@@ -391,28 +385,35 @@ XnStatus XnSensorIO::EnumerateSensors(XnConnectionString* aConnectionStrings, Xn
 	
 	if (devicesSet.Size() == 0)
 	{
-		// search for a v6.0.1 device
-		nRetVal = Enumerate(XN_SENSOR_6_0_1_PRODUCT_ID, devicesSet);
-		XN_IS_STATUS_OK(nRetVal);
-
-		// search for a v6.0 device
-		nRetVal = Enumerate(XN_SENSOR_6_0_PRODUCT_ID, devicesSet);
-		XN_IS_STATUS_OK(nRetVal);	
-	}
 #else
 	XnStringsHash devicesSet;
+#endif
+
+	// search for a MSK device
+	nRetVal = Enumerate(XN_SENSOR_MSK_VENDOR_ID, XN_SENSOR_MSK_PRODUCT_ID, devicesSet);
+	XN_IS_STATUS_OK(nRetVal);
+
+	// search for a v6.0.1 device
+	nRetVal = Enumerate(XN_SENSOR_VENDOR_ID, XN_SENSOR_6_0_1_PRODUCT_ID, devicesSet);
+	XN_IS_STATUS_OK(nRetVal);
+
+	// search for a v6.0 device
+	nRetVal = Enumerate(XN_SENSOR_VENDOR_ID, XN_SENSOR_6_0_PRODUCT_ID, devicesSet);
+	XN_IS_STATUS_OK(nRetVal);
 
 	// search for a v6.0.1 device
-	nRetVal = Enumerate(XN_SENSOR_6_0_1_PRODUCT_ID, devicesSet);
+	nRetVal = Enumerate(XN_SENSOR_VENDOR_ID, XN_SENSOR_5_0_PRODUCT_ID, devicesSet);
 	XN_IS_STATUS_OK(nRetVal);
 
 	// search for a v6.0 device
-	nRetVal = Enumerate(XN_SENSOR_6_0_PRODUCT_ID, devicesSet);
+	nRetVal = Enumerate(XN_SENSOR_VENDOR_ID, XN_SENSOR_2_0_PRODUCT_ID, devicesSet);
 	XN_IS_STATUS_OK(nRetVal);
 
 	// search for a v5.0 device
-	nRetVal = Enumerate(XN_SENSOR_5_0_PRODUCT_ID, devicesSet);
+	nRetVal = Enumerate(XN_SENSOR_VENDOR_ID, XN_SENSOR_5_0_PRODUCT_ID, devicesSet);
 	XN_IS_STATUS_OK(nRetVal);
+#if (XN_PLATFORM == XN_PLATFORM_MACOSX)
+  }
 #endif
 	
 	// now copy back
@@ -470,7 +471,8 @@ XnStatus XnSensorIO::SetCallback(XnUSBEventCallbackFunctionPtr pCallbackPtr, voi
 	XnStatus nRetVal = XN_STATUS_OK;
 	
 	// try to register callback to a 5.0 device
-	nRetVal = xnUSBSetCallbackHandler(XN_SENSOR_VENDOR_ID, XN_SENSOR_5_0_PRODUCT_ID, NULL, pCallbackPtr, pCallbackData);
+// --avin mod--
+//	nRetVal = xnUSBSetCallbackHandler(XN_SENSOR_VENDOR_ID, XN_SENSOR_5_0_PRODUCT_ID, NULL, pCallbackPtr, pCallbackData);
 
 	return nRetVal;
 }
diff --git a/Source/XnDeviceSensorV2/XnDeviceSensorIO.h b/Source/XnDeviceSensorV2/XnDeviceSensorIO.h
index 4c995ec..2067527 100644
--- a/Source/XnDeviceSensorV2/XnDeviceSensorIO.h
+++ b/Source/XnDeviceSensorV2/XnDeviceSensorIO.h
@@ -32,6 +32,17 @@
 #include "XnFirmwareInfo.h"
 
 //---------------------------------------------------------------------------
+// Defines
+//---------------------------------------------------------------------------
+#define XN_SENSOR_VENDOR_ID			0x1D27
+#define XN_SENSOR_2_0_PRODUCT_ID	0x0200
+#define XN_SENSOR_5_0_PRODUCT_ID	0x0500
+#define XN_SENSOR_6_0_PRODUCT_ID	0x0600
+#define XN_SENSOR_6_0_1_PRODUCT_ID      0x0601
+#define XN_SENSOR_MSK_VENDOR_ID   0x045E
+#define XN_SENSOR_MSK_PRODUCT_ID  0x02AE
+
+//---------------------------------------------------------------------------
 // Structures & Enums
 //---------------------------------------------------------------------------
 typedef struct XnUsbConnection
diff --git a/Source/XnDeviceSensorV2/XnDeviceSensorProtocol.h b/Source/XnDeviceSensorV2/XnDeviceSensorProtocol.h
index f00469e..87b4a45 100644
--- a/Source/XnDeviceSensorV2/XnDeviceSensorProtocol.h
+++ b/Source/XnDeviceSensorV2/XnDeviceSensorProtocol.h
@@ -82,7 +82,9 @@ typedef struct XnSensorProtocolResponseHeader
 {
 	XnUInt16 nMagic;
 	XnUInt16 nType;
-	XnUInt16 nPacketID;
+	// --avin mod--
+	XnUInt8  nPacketID;
+	XnUInt8  nUnknown;
 	XnUInt16 nBufSize;
 	XnUInt32 nTimeStamp;
 } XnSensorProtocolResponseHeader;
diff --git a/Source/XnDeviceSensorV2/XnFirmwareStreams.cpp b/Source/XnDeviceSensorV2/XnFirmwareStreams.cpp
index 16cca8d..b8d84e5 100644
--- a/Source/XnDeviceSensorV2/XnFirmwareStreams.cpp
+++ b/Source/XnDeviceSensorV2/XnFirmwareStreams.cpp
@@ -112,10 +112,11 @@ XnStatus XnFirmwareStreams::CheckClaimStream(const XnChar* strType, XnResolution
 			}
 
 			// check FPS
-			if (pIRStreamData->nFPS != nFPS)
-			{
-				XN_LOG_WARNING_RETURN(XN_STATUS_DEVICE_BAD_PARAM, XN_MASK_DEVICE_SENSOR, "Depth and IR streams must have the same FPS!");
-			}
+			// check FPS
+			//if (pIRStreamData->nFPS != nFPS)
+			//{
+			//	XN_LOG_WARNING_RETURN(XN_STATUS_DEVICE_BAD_PARAM, XN_MASK_DEVICE_SENSOR, "Depth and IR streams must have the same FPS!");
+			//}
 		}
 	}
 	else if (strcmp(strType, XN_STREAM_TYPE_IR) == 0)
@@ -144,10 +145,10 @@ XnStatus XnFirmwareStreams::CheckClaimStream(const XnChar* strType, XnResolution
 			}
 
 			// check FPS
-			if (pDepthStreamData->nFPS != nFPS)
-			{
-				XN_LOG_WARNING_RETURN(XN_STATUS_DEVICE_BAD_PARAM, XN_MASK_DEVICE_SENSOR, "Depth and IR streams must have the same FPS!");
-			}
+			//if (pDepthStreamData->nFPS != nFPS)
+			//{
+			//	XN_LOG_WARNING_RETURN(XN_STATUS_DEVICE_BAD_PARAM, XN_MASK_DEVICE_SENSOR, "Depth and IR streams must have the same FPS!");
+			//}
 		}
 	}
 	else if (strcmp(strType, XN_STREAM_TYPE_IMAGE) == 0)
diff --git a/Source/XnDeviceSensorV2/XnHostProtocol.h b/Source/XnDeviceSensorV2/XnHostProtocol.h
index fafca1c..ea49f0a 100644
--- a/Source/XnDeviceSensorV2/XnHostProtocol.h
+++ b/Source/XnDeviceSensorV2/XnHostProtocol.h
@@ -108,8 +108,8 @@ enum EPsProtocolOpCodes_V017
 typedef enum
 {
 	XN_HOST_PROTOCOL_ALGORITHM_DEPTH_INFO	= 0x00,
-	XN_HOST_PROTOCOL_ALGORITHM_REGISTRATION	= 0x02,
-	XN_HOST_PROTOCOL_ALGORITHM_PADDING		= 0x03,
+	XN_HOST_PROTOCOL_ALGORITHM_REGISTRATION	= 0x40,
+	XN_HOST_PROTOCOL_ALGORITHM_PADDING		= 0x41,
 	XN_HOST_PROTOCOL_ALGORITHM_BLANKING		= 0x06,
 	XN_HOST_PROTOCOL_ALGORITHM_DEVICE_INFO	= 0x07,
 	XN_HOST_PROTOCOL_ALGORITHM_FREQUENCY	= 0x80
diff --git a/Source/XnDeviceSensorV2/XnSensorDepthStream.cpp b/Source/XnDeviceSensorV2/XnSensorDepthStream.cpp
index 0e9c409..8ab2b37 100644
--- a/Source/XnDeviceSensorV2/XnSensorDepthStream.cpp
+++ b/Source/XnDeviceSensorV2/XnSensorDepthStream.cpp
@@ -319,6 +319,8 @@ XnStatus XnSensorDepthStream::ConfigureStreamImpl()
 	nRetVal = m_Helper.GetCmosInfo()->SetCmosConfig(XN_CMOS_TYPE_DEPTH, GetResolution(), GetFPS());
 	XN_IS_STATUS_OK(nRetVal);
 
+	// Thanks to avin again! :-)
+	XnHostProtocolSetParam(GetHelper()->GetPrivateData(), 0x105, 0);
 	return XN_STATUS_OK;
 }
 
diff --git a/Source/XnDeviceSensorV2/XnSensorDepthStream.h b/Source/XnDeviceSensorV2/XnSensorDepthStream.h
index 32aa364..d2ae80c 100644
--- a/Source/XnDeviceSensorV2/XnSensorDepthStream.h
+++ b/Source/XnDeviceSensorV2/XnSensorDepthStream.h
@@ -36,11 +36,11 @@
 // Defines
 //---------------------------------------------------------------------------
 #define XN_DEPTH_STREAM_DEFAULT_INPUT_FORMAT				XN_IO_DEPTH_FORMAT_UNCOMPRESSED_11_BIT
-#define XN_DEPTH_STREAM_DEFAULT_RESOLUTION					XN_RESOLUTION_QVGA
+#define XN_DEPTH_STREAM_DEFAULT_RESOLUTION					XN_RESOLUTION_VGA
 #define XN_DEPTH_STREAM_DEFAULT_FPS							30
 #define XN_DEPTH_STREAM_DEFAULT_OUTPUT_FORMAT				XN_OUTPUT_FORMAT_DEPTH_VALUES
 #define XN_DEPTH_STREAM_DEFAULT_REGISTRATION				FALSE
-#define XN_DEPTH_STREAM_DEFAULT_REGISTRATION_TYPE			XN_PROCESSING_DONT_CARE
+#define XN_DEPTH_STREAM_DEFAULT_REGISTRATION_TYPE	 		XN_PROCESSING_SOFTWARE
 #define XN_DEPTH_STREAM_DEFAULT_HOLE_FILLER					TRUE
 #define XN_DEPTH_STREAM_DEFAULT_WHITE_BALANCE				TRUE
 #define XN_DEPTH_STREAM_DEFAULT_GAIN_OLD					50
diff --git a/Source/XnDeviceSensorV2/XnSensorFirmwareParams.cpp b/Source/XnDeviceSensorV2/XnSensorFirmwareParams.cpp
index 4349d8c..6fee21e 100644
--- a/Source/XnDeviceSensorV2/XnSensorFirmwareParams.cpp
+++ b/Source/XnDeviceSensorV2/XnSensorFirmwareParams.cpp
@@ -510,10 +510,10 @@ XnStatus XnSensorFirmwareParams::SetImageResolution(XnUInt64 nValue)
 		case XN_RESOLUTION_VGA:
 			break;
 		case XN_RESOLUTION_SXGA:
-			if (m_pInfo->nFWVer < XN_SENSOR_FW_VER_5_3)
-			{
-				XN_LOG_WARNING_RETURN(XN_STATUS_IO_INVALID_STREAM_IMAGE_RESOLUTION, XN_MASK_DEVICE_SENSOR, "Image resolution is not supported by this firmware!");
-			}
+			//if (m_pInfo->nFWVer < XN_SENSOR_FW_VER_5_3)
+			//{
+			//	XN_LOG_WARNING_RETURN(XN_STATUS_IO_INVALID_STREAM_IMAGE_RESOLUTION, XN_MASK_DEVICE_SENSOR, "Image resolution is not supported by this firmware!");
+			//}
 			break;
 		case XN_RESOLUTION_UXGA:
 			if (m_pInfo->nFWVer < XN_SENSOR_FW_VER_5_1)
diff --git a/Source/XnDeviceSensorV2/XnSensorIRStream.cpp b/Source/XnDeviceSensorV2/XnSensorIRStream.cpp
index 4ede944..6014b7e 100644
--- a/Source/XnDeviceSensorV2/XnSensorIRStream.cpp
+++ b/Source/XnDeviceSensorV2/XnSensorIRStream.cpp
@@ -87,6 +87,7 @@ XnStatus XnSensorIRStream::Init()
 		{ 0, XN_RESOLUTION_QVGA, 60 },
 		{ 0, XN_RESOLUTION_VGA, 30 },
 		{ 0, XN_RESOLUTION_SXGA, 30 },
+		{ 0, XN_RESOLUTION_SXGA, 15 },
 	};
 	nRetVal = AddSupportedModes(aSupportedModes, sizeof(aSupportedModes)/sizeof(aSupportedModes[0]));
 	XN_IS_STATUS_OK(nRetVal);
@@ -96,6 +97,7 @@ XnStatus XnSensorIRStream::Init()
 		XnCmosPreset aSupportedModesSXGA[] = 
 		{
 			{ 0, XN_RESOLUTION_SXGA, 30 },
+			{ 0, XN_RESOLUTION_SXGA, 15 },
 		};
 		nRetVal = AddSupportedModes(aSupportedModesSXGA, sizeof(aSupportedModesSXGA)/sizeof(aSupportedModesSXGA[0]));
 		XN_IS_STATUS_OK(nRetVal);
diff --git a/Source/XnDeviceSensorV2/XnSensorImageStream.cpp b/Source/XnDeviceSensorV2/XnSensorImageStream.cpp
index a2c0e90..41eaeb2 100644
--- a/Source/XnDeviceSensorV2/XnSensorImageStream.cpp
+++ b/Source/XnDeviceSensorV2/XnSensorImageStream.cpp
@@ -39,7 +39,7 @@
 //---------------------------------------------------------------------------
 // XnSensorImageStream class
 //---------------------------------------------------------------------------
-XnSensorImageStream::XnSensorImageStream(const XnChar* strDeviceName, const XnChar* StreamName, XnSensorObjects* pObjects, XnUInt32 nBufferCount, XnBool bAllowOtherUsers) : 
+XnSensorImageStream::XnSensorImageStream(const XnChar* strDeviceName, const XnChar* StreamName, XnSensorObjects* pObjects, XnUInt32 nBufferCount, XnBool bAllowOtherUsers) :
 	XnImageStream(StreamName, FALSE),
 	m_Helper(pObjects),
 	m_BufferPool(nBufferCount, strDeviceName, StreamName, GetMaxBufferSize(m_Helper.GetFirmwareVersion()), bAllowOtherUsers),
@@ -108,9 +108,9 @@ XnStatus XnSensorImageStream::Init()
 	m_LowLightCompensation.UpdateSetCallback(SetLowLightCompensationCallback, this);
 
 	// add properties
-	XN_VALIDATE_ADD_PROPERTIES(this, &m_InputFormat, &m_AntiFlicker, &m_ImageQuality, 
-		&m_Brightness, &m_Contrast, &m_Saturation, &m_Sharpness,  
-		&m_ColorTemperature, &m_BackLightCompensation, &m_Gain, &m_Zoom, 
+	XN_VALIDATE_ADD_PROPERTIES(this, &m_InputFormat, &m_AntiFlicker, &m_ImageQuality,
+		&m_Brightness, &m_Contrast, &m_Saturation, &m_Sharpness,
+		&m_ColorTemperature, &m_BackLightCompensation, &m_Gain, &m_Zoom,
 		&m_Exposure, &m_Pan, &m_Tilt, &m_LowLightCompensation,
 		&m_SharedBufferName, &m_ActualRead);
 
@@ -139,6 +139,9 @@ XnStatus XnSensorImageStream::Init()
 	XN_IS_STATUS_OK(nRetVal);
 
 	// register supported modes
+	int nVid, nPid;
+	sscanf(m_Helper.GetPrivateData()->DeviceConfig.cpConnectionString, "%x/%x", &nVid, &nPid);
+
 	if (m_Helper.GetFirmwareVersion() >= XN_SENSOR_FW_VER_5_4)
 	{
 		// ask the firmware
@@ -173,7 +176,7 @@ XnStatus XnSensorImageStream::Init()
 				if (aSupportedModes[i].nFormat == XN_IMAGE_STREAM_DEFAULT_INPUT_FORMAT)
 				{
 					nValidInputFormat = XN_IMAGE_STREAM_DEFAULT_INPUT_FORMAT;
-					break;					
+					break;
 				}
 			}
 		}
@@ -199,6 +202,55 @@ XnStatus XnSensorImageStream::Init()
 		nRetVal = AddSupportedModes(aSupportedModes, nCount);
 		XN_IS_STATUS_OK(nRetVal);
 	}
+	else if (nVid == XN_SENSOR_MSK_VENDOR_ID && nPid == XN_SENSOR_MSK_PRODUCT_ID)
+	{
+		XnArray<XnCmosPreset> supportedModes(30);
+
+		XN_IS_STATUS_OK(nRetVal);
+		nRetVal = AddSupportedMode(supportedModes, XN_IO_IMAGE_FORMAT_BAYER, XN_RESOLUTION_VGA, 30);
+		XN_IS_STATUS_OK(nRetVal);
+
+		// Enable uncompressed Bayer
+		nRetVal = AddSupportedMode(supportedModes, XN_IO_IMAGE_FORMAT_UNCOMPRESSED_BAYER, XN_RESOLUTION_SXGA, 15);
+		XN_IS_STATUS_OK(nRetVal);
+		nRetVal = AddSupportedMode(supportedModes, XN_IO_IMAGE_FORMAT_UNCOMPRESSED_BAYER, XN_RESOLUTION_VGA, 30);
+
+		// high-res
+		if (m_Helper.GetFirmwareVersion() >= XN_SENSOR_FW_VER_5_3)
+		{
+			nRetVal = AddSupportedMode(supportedModes, XN_IO_IMAGE_FORMAT_BAYER, XN_RESOLUTION_SXGA, 30);
+			XN_IS_STATUS_OK(nRetVal);
+
+			// starting with 5.3.28, YUV is also supported in high-res
+			if (m_Helper.GetPrivateData()->Version.nMajor > 5 ||
+				(m_Helper.GetPrivateData()->Version.nMajor == 5 && m_Helper.GetPrivateData()->Version.nMinor > 3) ||
+				(m_Helper.GetPrivateData()->Version.nMajor == 5 && m_Helper.GetPrivateData()->Version.nMinor == 3 && m_Helper.GetPrivateData()->Version.nBuild >= 28))
+			{
+				nRetVal = AddSupportedMode(supportedModes, XN_IO_IMAGE_FORMAT_BAYER, XN_RESOLUTION_SXGA, 30);
+				XN_IS_STATUS_OK(nRetVal);
+
+				nRetVal = AddSupportedMode(supportedModes, XN_IO_IMAGE_FORMAT_UNCOMPRESSED_BAYER, XN_RESOLUTION_SXGA, 30);
+				XN_IS_STATUS_OK(nRetVal);
+			}
+		}
+		else if (m_Helper.GetFirmwareVersion() >= XN_SENSOR_FW_VER_5_2)
+		{
+			// on 5.2, high-res was UXGA
+			nRetVal = AddSupportedMode(supportedModes, XN_IO_IMAGE_FORMAT_BAYER, XN_RESOLUTION_UXGA, 30);
+			XN_IS_STATUS_OK(nRetVal);
+		}
+
+		// Add all supported modes to the stream
+		nRetVal = AddSupportedModes(supportedModes.GetData(), supportedModes.GetSize());
+		XN_IS_STATUS_OK(nRetVal);
+
+		if (m_InputFormat.GetValue() != XN_IO_IMAGE_FORMAT_BAYER && m_InputFormat.GetValue() != XN_IO_IMAGE_FORMAT_UNCOMPRESSED_BAYER)
+		{
+			// update default input format
+			nRetVal = m_InputFormat.UnsafeUpdateValue(XN_IO_IMAGE_FORMAT_UNCOMPRESSED_BAYER);
+			XN_IS_STATUS_OK(nRetVal);
+		}
+	}
 	else
 	{
 		XnArray<XnCmosPreset> supportedModes(30);
@@ -226,7 +278,8 @@ XnStatus XnSensorImageStream::Init()
 		}
 
 		// starting with FW 5.2, 25 FPS is also supported
-		if (m_Helper.GetFirmwareVersion() >= XN_SENSOR_FW_VER_5_2)
+		//Suat: changed to 5_1 since out 5_1_6 works good with 25Hz
+		if (m_Helper.GetFirmwareVersion() >= XN_SENSOR_FW_VER_5_1)
 		{
 			nRetVal = AddSupportedMode(supportedModes, XN_IO_IMAGE_FORMAT_YUV422, XN_RESOLUTION_QVGA, 25);
 			XN_IS_STATUS_OK(nRetVal);
@@ -355,7 +408,7 @@ XnStatus XnSensorImageStream::MapPropertiesToFirmware()
 XnStatus XnSensorImageStream::ValidateMode()
 {
 	XnStatus nRetVal = XN_STATUS_OK;
-	
+
 	// validity checks
 	XnIOImageFormats nInputFormat = (XnIOImageFormats)m_InputFormat.GetValue();
 	XnOutputFormats nOutputFormat = GetOutputFormat();
@@ -370,7 +423,7 @@ XnStatus XnSensorImageStream::ValidateMode()
 			nInputFormat != XN_IO_IMAGE_FORMAT_UNCOMPRESSED_YUV422 &&
 			nInputFormat != XN_IO_IMAGE_FORMAT_BAYER)
 		{
-			XN_LOG_WARNING_RETURN(XN_STATUS_DEVICE_BAD_PARAM, XN_MASK_DEVICE_SENSOR, "Input format %d cannot be converted to RGB24!", nInputFormat);
+			//XN_LOG_WARNING_RETURN(XN_STATUS_DEVICE_BAD_PARAM, XN_MASK_DEVICE_SENSOR, "Input format %d cannot be converted to RGB24!", nInputFormat);
 		}
 		break;
 	case XN_OUTPUT_FORMAT_YUV422:
@@ -561,7 +614,7 @@ XnStatus XnSensorImageStream::SetOutputFormat(XnOutputFormats nOutputFormat)
 
 	nRetVal = m_Helper.AfterSettingDataProcessorProperty();
 	XN_IS_STATUS_OK(nRetVal);
-	
+
 	return (XN_STATUS_OK);
 }
 
@@ -647,10 +700,10 @@ XnStatus XnSensorImageStream::SetInputFormat(XnIOImageFormats nInputFormat)
 XnStatus XnSensorImageStream::SetAntiFlicker(XnUInt32 nFrequency)
 {
 	XnStatus nRetVal = XN_STATUS_OK;
-	
+
 	nRetVal = m_Helper.SimpleSetFirmwareParam(m_AntiFlicker, (XnUInt16)nFrequency);
 	XN_IS_STATUS_OK(nRetVal);
-	
+
 	return (XN_STATUS_OK);
 }
 
@@ -661,7 +714,7 @@ XnStatus XnSensorImageStream::SetImageQuality(XnUInt32 /*nQuality*/)
 	{
 		XN_LOG_WARNING_RETURN(XN_STATUS_DEVICE_UNSUPPORTED_PARAMETER, XN_MASK_DEVICE_SENSOR, "Image quality is only supported when input format is JPEG");
 	}
-	
+
 	return (XN_STATUS_OK);
 }
 
@@ -826,7 +879,7 @@ XnStatus XnSensorImageStream::ReallocTripleFrameBuffer()
 
 	if (IsOpen())
 	{
-		// before actually replacing buffer, lock the processor (so it will not continue to 
+		// before actually replacing buffer, lock the processor (so it will not continue to
 		// use old buffer)
 		nRetVal = m_Helper.GetFirmware()->GetStreams()->LockStreamProcessor(GetType(), this);
 		XN_IS_STATUS_OK(nRetVal);
diff --git a/Source/XnDeviceSensorV2/XnSensorImageStream.h b/Source/XnDeviceSensorV2/XnSensorImageStream.h
index a975820..fea1f51 100644
--- a/Source/XnDeviceSensorV2/XnSensorImageStream.h
+++ b/Source/XnDeviceSensorV2/XnSensorImageStream.h
@@ -33,7 +33,7 @@
 // Defines
 //---------------------------------------------------------------------------
 #define XN_IMAGE_STREAM_DEFAULT_FPS				30
-#define XN_IMAGE_STREAM_DEFAULT_RESOLUTION		XN_RESOLUTION_QVGA
+#define XN_IMAGE_STREAM_DEFAULT_RESOLUTION		XN_RESOLUTION_VGA
 #define XN_IMAGE_STREAM_DEFAULT_INPUT_FORMAT	XN_IO_IMAGE_FORMAT_UNCOMPRESSED_YUV422
 #define XN_IMAGE_STREAM_DEFAULT_OUTPUT_FORMAT	XN_OUTPUT_FORMAT_RGB24
 #define XN_IMAGE_STREAM_DEFAULT_FLICKER			0
@@ -169,4 +169,4 @@ private:
 	XnActualIntProperty m_ActualRead;
 };
 
-#endif //__XN_SENSOR_IMAGE_STREAM_H__
\ No newline at end of file
+#endif //__XN_SENSOR_IMAGE_STREAM_H__
